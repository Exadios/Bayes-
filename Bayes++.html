<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
        <META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=utf-8">
        <TITLE>Bayes++ Bayesian Filtering</TITLE>
        <LINK REL="stylesheet" HREF="Deployment/paper.css" TYPE="text/css">
</HEAD>
<H1 ALIGN=CENTER><U>Bayes++</U></H1>
<H1 ALIGN=CENTER><B>Open Source Bayesian Filtering Classes</B></H1>
<H2 ALIGN=CENTER>Michael Stevens</H2>

<P STYLE="margin-bottom: 0cm"><BR>
</P>
<CENTER>
        <TABLE WIDTH=100% BORDER=5 CELLPADDING=0 CELLSPACING=4 BGCOLOR="#c0c0c0">
                <TR VALIGN=TOP>
                        <TD WIDTH=368 HEIGHT=48>
                                <H2><A HREF="Bayesian Filtering Classes.html">Bayesian Filtering</A></H2>
                                <P>Overview of Bayesian filtering with the Filtering Classes
                                </P>
                        </TD>

                        <TD WIDTH=330>
                                <H2 ALIGN=RIGHT><A HREF="mailto:mail@michael-stevens.de">mail@michael-stevens.de</A></H2>
                                <H2 ALIGN=RIGHT><A HREF="http://www.acfr.usyd.edu.au/">Australian
                                Centre for Field Robotics</A></H2>
                        </TD>
                </TR>
                <TR VALIGN=TOP>
                        <TD WIDTH=368>
                                <H3><A HREF="ClassDocumentation/html/index.html">Documentation
                                generated by Doxygen</A></H3>

                                <BLOCKQUOTE><A HREF="ClassDocumentation/html/classBayesian__filter_1_1Bayes__filter__base.html">Filter
                                hierarchy</A><BR><A HREF="ClassDocumentation/html/classBayesian__filter_1_1Predict__model__base.html">Prediction
                                models</A> and <A HREF="ClassDocumentation/html/classBayesian__filter_1_1Observe__model__base.html">Observation
                                models</A><BR><BR><A HREF="ClassDocumentation/html/functions.html">Class
                                members</A> and <A HREF="ClassDocumentation/html/files.html">File
                                list of Bayes++</A>
                                </BLOCKQUOTE>
                        </TD>
                        <TD WIDTH=330>

                                <H3 ALIGN=RIGHT><A NAME="download"></A><A HREF="http://sourceforge.net/projects/bayesclasses/">Project
                                Summary</A> and <A HREF="http://sourceforge.net/project/showfiles.php?group_id=54729">Download</A></H3>
                                <P ALIGN=RIGHT><A NAME="SVN_Repository"></A><IMG SRC="http://sourceforge.net/sflogo.php?group_id=54729&amp;type=5" NAME="Grafik1" ALT="SourceForge Logo" ALIGN=TOP WIDTH=120 HEIGHT=40 BORDER=0>
                                <A HREF="http://svn.sourceforge.net/bayesclasses">SVN Repository</A>
                                <BR>Bayes++ uses the <A HREF="http://www.boost.org/" TARGET="_top"><FONT SIZE=5>Boost</FONT></A><BR>peer-reviewed
                                portable C++ source libraries</P>
                        </TD>

                </TR>
        </TABLE>
</CENTER>
<P ALIGN=LEFT>
      Bayesian Filtering is a probabilistic technique for data fusion. The technique combines a concise mathematical formulation of a system with observations of that system. Probabilities are used to represent the state of a system, likelihood functions to represent their relationships. In this form Bayesian inference can be applied and further related probabilities deduced. See <A HREF="http://www.wikipedia.org/">Wikipedia</A> for information on <A HREF="http://www.wikipedia.org/wiki/Probability_theory">Probability
theory</A>, <A HREF="http://www.wikipedia.org/wiki/Bayes'_theorem">Bayes
theorem</A>, <A HREF="http://www.wikipedia.org/wiki/Bayesian_inference">Bayesian
Inference</A>.</P>

<P ALIGN=LEFT>For <U>discrete</U> systems the Bayesian formulation
results in a naturally iterative data fusion solution. For <U>dynamic</U>
systems there is a class of solutions, discrete <U>filters</U>, that combine observed outputs of the system with the system's dynamic model. An <U>estimator</U> computes a estimate of the systems state with each observation
of the system. Linear estimators such as the Kalman Filter are commonly applied.</P>
<P ALIGN=LEFT>Bayes++ is an open source library of C++ classes. These
classes represent and implement a wide variety of numerical
algorithms for Bayesian Filtering of discrete systems. The classes
provide tested and consistent numerical methods and the class
hierarchy explicitly represents the variety of filtering algorithms
and system model types.</P>
<H2>Simple Example</H2>

<P>This is very simple example; for those who have never used the
Bayesian Filtering Classes before. If you wish to see how simple it
is to use Bayes++ then <A HREF="Simple/simpleExample.cpp">View the
Source</A>.</P>
<P>The example shows how two classes are created. The first is the
prediction model, the second the observation model. In this example
they represent a simple linear problem with only one state variable
and constant model noises. A filter fuses the results of prediction
and observation.</P>
<P>See the <A HREF="Bayesian Filtering Classes.html">Bayesian
Filtering classes</A> for a description of the classes used and
all three examples provided with Bayes++.</P>
<H2>Compiling the Examples</H2>
<P>First <A HREF="#download">download</A> and extract <B>Bayes++</B>

and also the <B>Boost</B> library. <B>Boost</B> is used to provide
compiler independence, and a common build system. Two Boost header
libraries are used: <B>uBLAS</B> for linear algebra, and <B>random</B>
for the PV and QuadCalib examples. The Boost headers can be placed
anywhere relative to Bayes++, but it is easy if you follow this
structure:</P>
<DL>
        <DD><DL>

                <DT><EM>...sourceDirectory</EM></DT>
                <DD><DL>
                        <DT>Bayes++</DT>
                                <DD>BayesFilter</DD>
                                <DD>PV</DD>
                                <DD>QuadCalib</DD>

                                <DD>Simple</DD>
                                <DD>Test</DD>
                </DL></DD>
                <DD><DL>
                        <DT>boost_1_43_0</DT>
                                <DD>boost</DD>
                                <DD><I>etc</I></DD>

                </DL></DD>
        </DL></DD>
</DL>
<P>
<P>
Using the Boost Build system version 2 is the best way to compile the
examples. Use the <B>bjam</B> (Boost jam) program build Bayes++ in
a single step. The documentation in your
downloaded copy of Boost explains how to obtain compile the latest
version of bjam yourself. For everything to work <B>bjam</B> executed
with the required toolset, or sometimes you need to configure the Build
system to tell it where your compiler is.
<BR>To build Bayes++ and the examples simply
execute: (Bayes++ should be the current directory)</P>
<PRE STYLE="margin-bottom: 0.5cm">        bjam toolset=gcc -sBOOST_ROOT=&quot;../boost_1_43_0&quot;</PRE><P>
<P>OR for C++ execute:</P>
<PRE STYLE="margin-bottom: 0.5cm">        bjam toolset=msvc -sBOOST_ROOT=&quot;../boost_1_43_0&quot;</PRE><P>
It is possible to drop the BOOST_ROOT variable by either creating a
<B>build_build.jam</B> file in <I>sourceDirectory</I> (or above) or
by setting it as an environment variable.</P>
</P>
<H4>Location of compiled examples and libraries</H4>

<P>The executables for the three examples will be placed inside a
directory hierarchy named <B>target</B>. Static libraries for debug
and release builds of the <B>BayesFilter</B> library are placed in
<B>target/BayesFilter</B>. The <B>target</B> directory and its subdirectories
are created automatically.</P?
<H4>Visual C++ solution</H4>
<P>For Visual C++ 2008 etc, you can also use the <B>Bayes++.sln</B> solution
and the active configuration <B>uBLAS Debug</B>. The compiler options
must be set so the <B>Boost</B> include files can be found. That is,
the <U>include path</U> must contain the base directory of Boost. In
this case the local <B>boost</B> directory. In VC7.1 you should do
this by choosing the <I>Tools/Options/Projects/VC++ Directories</I>
option.</P>
<P>Visual C++ 7.0 requires the use of Boost version 1_32_0. Visual C++ 7.1 (or later) requires Boost version 1_33_0 (or later).I</P>
<H2>Licensing</H2>
<P>All Bayes++ source code files are copyright with the license
conditions as given here. The copyright notice is that of the MIT
license. This in no way restricts any commercial use you may wish to
make using our source code. As long as you respect the copyright and
license conditions, Michael Stevens and the Australian Centre for
Field Robotics are happy to for you to use it in any way you wish.</P>
<P>Bayes++ the Bayesian Filtering Library</P>
<P>Copyright (c) 2003,2004,2005 Michael Stevens, Copyright (c) 2002
Michael Stevens and Australian Centre for Field Robotics</P>
<P>Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation files
(the &quot;Software&quot;), to deal in the Software without
restriction, including without limitation the rights to use, copy,
modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished
to do so, subject to the following conditions:</P>
<P>The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.</P>

<P>THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF
ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.</P>
<H2>SLAM : Simultaneous Localization and Mapping</H2>
<P>SLAM is one of the most interesting problems in Bayesian
filtering. It's structure implies that it cannot be correctly solved
without using stochastic approach. This is due to mapped states being
dependent on other mapped states and the localization state. This
dependence also make the problem complex, therefore a simple approach
such as representing all correlations is not tractable for large
numbers of states.</P>
<P>Bayes++ has been used to implement various simple and some more
advanced SLAM solutions. In particular a full implementation of
FastSLAM has been implemented. This technique is described in the
paper &quot;FastSLAM : Factored Solution to the Simultaneous
Localization and Mapping Problem&quot;, M. Montemerlo, S. Thrun S, D.
Koller, B. Wegbreit, Proceedings of the AAAI National Conference on
Artificial Intelligence 2002.</P>
<P>The Bayes++ implementation of FastSLAM and a very simple Kalman
(full correlation) SLAM implementation is available as part of the
most recent <A HREF="#download">download</A>.</P>
<H2>Scilab, Matlab, MuPAD</H2>

<P>These mathematical tools are particularly useful for visualising
filtering results. However they are all rather slow, and it is very
easy to produce very poorly implemented filters in their programming
languages. Fortunately all these tools provide mechanisms for
extension with external programs. Example interface code is provided
in the <A HREF="#CVS_Repository">Bayes++ CVS repository</A> for
Matlab and MuPAD. An interface to Scilab is not yet available.</P>
<H2>Portability</H2>
<P>Bayes++ only makes use of ISO standard C++. The source code uses
moderately advance C++ constructs. It only makes restricted use of
the C++ template system directly. However the Boost libraries used
(in particular uBLAS) make extensive use of template techniques.
Boost also includes many workarounds for compiler deficiencies.
Therefore with few alterations Bayes++ should work with any modern
C++ compiler supported by Boost.</P>
<P>Bayes++ is tested with: <B>Boost 1.43.0</B></P>
<P>Bayes++ is tested with: <B>GCC 4.6.0</B>, and
<B>VisualC++ 2008</B></P>
<P>Later versions of GCC 3.x and GCC 4.x should also run Bayes++ with ease.
However GCC 3.3.0 is know to be incompatible with uBLAS and to
produce incorrect code with -O2 optimization.</P>
<P>VisualC++ 7.1 often requires
the /Zm option to be used so it can compile complex headers.</P>
<H2>Release Criteria</H2>
<P>This releases is validated using the compilers and Boost versions
listed above using the following tests.
</P>
<OL>
<LI><P>Build system: Compatibility with Boost Build version 2.
<BR>Successfully complete <B>bjam</B> to build default
libraries and examples.<BR>Successfully complete <B>bjam</B> to build
SLAM system.</P>

<LI><P>Test examples: simpleExample, PV, QuadCalib <BR>Compile debug
and release builds (using Boost Build version 2) :- with no errors
and no warnings.<BR>Execution output :- Identical to expected
reference results.</P>
<LI><P>Numerical tests: rtheta - Range angle observer.<BR>A
non-linear range angle observer test. The observer moves in a 2
dimensional state space. Motion prediction occurs with a linear
model with additive noise. The two states are coupled both in the
model and in additive noise. Range and angle of a fixed target is
observed. The target is placed so discontinues angles are
observed.<BR>Both the state and the observations have additional non
observed (singular) states. Model sizes, coupling parameters and
model types can be varied for additional tests. All schemes are
tested over 5 iterations of the model. The SIR scheme is
tested with 1000 samples.<BR>Because the different numerical
implementations results are not expected to be identical between
Schemes. Therefore testing requires:<BR>Regression testing :-
Changed in output for any Scheme from the previous
release.<BR>Consistency testing :- Comparison of the output for
Scheme pairs know to produce numerically similar results.</P>
<LI><P>SLAM test: testFastSLAM<BR>Consistency testing :- Comparison
of FastSLAM result with 1,000,000 samples with Kalman SLAM.
Deviations of state and covariance expected to be approx 1/1000th.</P>
</OL>
<H2><A NAME="FAQ"></A>FAQ</H2>
<a ref="Bayes++FAQ">Questions are answered in the Bayes++ FAQ</a>

<H2><A NAME="whatsnew"></A>What's new in Bayes++ 2012.5-1</H2>
<P>Renamed all classes which were previously named 'addative' to be called 'additive'.<P>
<P>Tested with <B>Boost 1.49.0</B>.</P>
<P>Cleanup comments in source.<P>

<H2>What's new in Bayes++ 2010.8-1</H2>
<P>Cleanup documentation and build files to make things build easily.<P>

<H2>What's new in Bayes++ 2003.8-5</H2>

<P>Support for and requires <B>Boost 1_33_0</B>.</P>
<H3>Compiler support</H3>
<P>The list of compilers for which Bayes++ is built and tested has
been update.
<H2>What's new in Bayes++ 2003.8-4</H2>
<P>New Documentation and support for <B>Boost 1_32_0</B>.</P>
<P>Sample covariances are now computed using the definition for the Maximum Likelihood (biased) estimate. This estimate simply
devides by 1/n the number of samples, rather then 1/(n-1). See <A href="http://en.wikipedia.org/wiki/Bias_(statistics)"> Sample Statistics in Wikipedia</A>.</P>

<H3>Compiler support</H3>
<P>The list of compilers for which Bayes++ is built and tested has
been update.
<H2>Bayes++ 2003.8-3</H2>
<P>Corrects documentation and support for Boost Build (version 1).</P>
<P>SLAM has been updated from the current development version.</P>
<H3>Compiler support</H3>
<P>GCC 3.4 requires a couple
of <I>typename</I> fixes to uBLAS (Boost_1_31_0 or earlier).</P>
<H2>Bayes++ 2003.8-2</H2>

<H3>New Boost Support</H3>
<P>Bayes++ is tested with both <B>Boost-1.30.2</B> and <B>Boost_1_31_0</B>.
</P>
<P>Jens Mauer has been working hard on getting <B>boost::random</B>
accepted as part of the future C++ standard library. To this end
there have been substantial changes to its interface. The new library
is now part of Boost_1_31_0. The Bayes++ examples make use of
boost::random. So things migrate smoothly I have added a new
&quot;test/random.hpp&quot; header which hides the interface changes.</P>

<P>The very excellent <B>Boost Build system version 2 </B>has
advanced a great deal recently. Bayes++ is built with standard Boost
Build system. To select the version 2 build system, simply use &quot;bjam
--v2&quot;. Bayes++ has all the necessary &quot;Jamfiles.v2&quot; to
use the new system.</P>
<H3>Scheme extensions</H3>
<P>The UD_scheme observe functions have had their numerical
capabilities extended. It is now possible to work with singular (zero
variance) covariance matrices.</P>
<P>The Unscented_scheme has additional function init_XX() and
update_XX() to allow access to an Unscented state representation.</P>
<H3>Numeric fixes</H3>

<P>An error in <I>SIR_kalman_schemes</I> covariance calculation has
been fixed. This error also effected the <I>Fast_kalman_SLAM</I>
implementation. The error was significant for small small sizes.</P>
<H2>Bayes++ 2003-5</H2>
<H3>'noalias' assignment</H3>
<P>For efficiency it is important to avoid creating temporary matrix
and vector copies. Unless told otherwise it is not possible for <B>uBLAS
</B>to determine if the same matrix or vector variable is specified
on both the left and right hand side of an assignment operation. If
such variable does appear it is said to be an <I>alias</I>. Because
assignment involves more then one element, the presence of an alias
requires that an assignment first compute a temporary result before
the aliased variable is modified.</P>

<P><B>uBLAS</B>'s default behavior is to create such a temporary. If
the assignment is know to be free of an alias this should be avoided.
Previously such an optimized assignment was specified with the
<B>.assign()</B> member functions. To improve the readability of code
I have added a new syntax for assignment. Where no aliases of
variable assigned to (lvalue) appears in the expression on the right
hand side of the assignment use:</P>
<PRE STYLE="margin-bottom: 0.5cm"> noalias(lvalue) = expression;</PRE><P>
This new syntax is experimental but will probably be part of a future
<B>uBLAS</B> release. At present the implementation introduces a
small overhead on the supported compilers. This includes GCC 3.2.</P>
<H2>Bayes++ 2003-3</H2>
<H3>Filters are named <I>_filter</I>, Schemes are named <I>_scheme</I></H3>

<P>Abstract filters and numeric schemes previously all had names
ending in <I>_filter</I>. To make things simpler the naming has been
changed to make a clear separation in what is a two level hierarchy.</P>
<P>Filters lie at the base of the hierarchy. Schemes are always
derived from one of more filters. Filters represent abstract
concepts, such as the statistics of state representation and model
interface. Schemes are concrete implementations of a filter with all
the numeric details and interfaces completed.</P>
<P>As part of this change the statistics of state representation have
been made <B>virtual base classes</B>. This change is designed to
allow multiple schemes combined together (using multiple inheritance)
and share their representation. The change adds a little more work if
you choose to derive from a scheme class. The constructors for the
derived class must call the constructors for the virtual base classes
directly.</P>
<H3>Covariance Intersect Scheme added</H3>
<P>Finally the <B>CI</B> algorithm has been implemented as a Scheme
in Bayes++. CI is interesting as it provides a weaker but more robust
fusion then traditional covariance based method such as the Kalman
filter. It estimates state and an upper bound of what its covariance
could be.<BR><BR>Actually only the matrix algebra associated with CI
has is included. The CI_filter scheme provides a virtual function
where the user must define the actual optimization algorithm to be
used.</P>

<H3>Importance Resampling infrastructure added</H3>
<P>The flexibility of the <I>SIR_filter </I>has been greatly
improved. A new class <I>Importance_resampler</I> has been added.
Whenever <I>SIR_filter </I>need to re-sample it uses and
Importance_resampler parameter. Therefore by changing this parameter,
different re-samplers can be used.
</P>
<P>Two implementation are provided. The <I>Standard_resampler</I> and
the <I>Systematic_resampler</I>. See the referenced publications for
further discussion of these methods.</P>

<H3>Gappy Matrices</H3>
<P>The matrix interface has been further improved. These improvement
require uBLAS from boost_1_30_0. With this version there is
experimental support for using uBLAS <B>gappy</B> matrices and
vectors (sparse, compressed, coordinate).</P>
<P>The experimental support makes all of Bayes++ use a selected uBLAS
storage type. Check <B>matSupSub.hpp </B>for macro's required to
enable this. The algorithms used is Bayes++ are being upgraded to
perform better with sparse types.</P>
<P>The mult_SPD products are no longer supported. They are replaced
with the prod_SPD interface.</P>
<H3><A NAME="References1"></A>Copyright</H3>
<P ALIGN=LEFT>Copyright (c) 2003, 2004, 2005 Michael Stevens. This document is
part of the Bayes++ library - see licensing section for copyright
license details.</P>

</BODY>
</HTML>
