Bayes++ TODO List

FOR RELEASE
		Doxygen!
		Build gcc-3.2 gcc-2.95 msvcms intelinux-70
		Check VC7 solution
	Check what UBLAS macros are needed
		For exceptions/errors
		For storage
	Run Simple, PV, QuadCalib, SLAM

DOCUMENTATION
	Describe generic schemes
	Why Gq noise model. It is always non signular. Important for any numerics
		Q may have zeros. But if we have G then linear algebra can still use inverse.
		This is also why inverse(G) is not needed in inverse model. It would not be defined for signular Q
	Numeric postcondition. May not be PSD
	Models are implicity/explictly parameterised by state
	Use BoostBook to consistenently document pre/postconditions

TODO
	By products: add observe parameterisation for by products and temps
		observe innovation, surely it is something that is always computable by all schemes
			This should be the first "by_product"
	Extended_fiilter would be the place for an update managment helper
	Replace UdU function with UdU class. Requires a general uBLAS factor object

NEW FILTERS
	Factorised UKF or DDF2
	VSDF (factorised from) from Matt Deans
	SIR with Auxilary variables
	Sparse matrix implementations: Requires sparse UdU. Great care of ublas sparse_matrix as it is row/column major
	 This make a big difference to speed. Hard for prod(L,R) need to have oposite orienation

TO REVIEW
	Sharing state in filters, alternative to MI is constructors with state references (closures)
	Check consistency of model to filter
		Validate (z to h.Z) model sizes in predict and observe
	UDpredict catching Negative matrices in observe
	Check normalisation: Standard form should be to normalise(z,zp). This ensure z is consistent with zp and other model parts such as Hx
	Check when numerics fail for both state and obs semidefinate

CODE RULES
	filter
		assigment operator, optimised to remove temps
	predict/observe
		in BayesFlt.h	must be virtual. The types are polymorphic
		in xxFlt.h		no vitual. These are specialised forms
	filter_matrix
		use Vec/Matrix noalias(x) = prod(a,b); avoiding copy overhead. However a=b; is automatical efficient

TESTING
	Unscented_filter
		for q_size > x_size  Don´t forget more noise is injected into nonlinear model => different observe result!



// Hmmm this seems NOT to be the best algorithm numerically
// The good one from A+G uses element multiples
template<class M>
bool compact_cholesky (M &m)
{
	using namespace ublas;
	bool negative = false;
	size_t size = m.size1();
	for (size_t i = 0; i < size; ++ i)
	{
		typename M::value_type t (m (i, i));
		vector_range<matrix_column<M> > v(project(column(m,i), range(i+1,size)));
		v -=
			prod(project (m, range (i + 1, size), range (0, i)),
			conj (project (row (m, i),range (0, i))));
		t -= inner_prod (conj (project (row(m, i), range (0,i))),project (row (m, i),range (0, i)));
		if (t <= 0)  {
			negative = true;
			break;
		};
		t = std::sqrt (t);
		m (i, i) = t;
		v /= t;
	}
	return negative;
}
