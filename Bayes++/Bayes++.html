<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN"><html><head>
	
  <meta http-equiv="CONTENT-TYPE" content="text/html; charset=iso-8859-1">
  <title>Bayes++ Bayesian Filtering</title>

	
	
  <link rel="stylesheet" href="Deployment/paper.css" type="text/css">
</head>

<body lang="en-US">
<h1 align="center" style="text-decoration: underline;">Bayes++</h1>

<h1 align="center">Open
Source Bayesian Filtering Classes</h1>

<center>
	<table width="93%" border="5" cellpadding="2" cellspacing="3" bgcolor="#c0c0c0">
		<col width="111*">
		<col width="59*">
		<col width="86*">
		<tbody><tr valign="top">
			<td rowspan="2" width="43%">
				<h2><a href="./Bayesian%20Filtering%20Classes.html">Bayesian
				Filtering</a></h2>
				<p>Overview
				of Bayesian filtering with the Filtering Classes 
			</p></td>
			<td width="23%" height="15">
				<h2 align="left">Michael
				Stevens</h2>
			</td>
			<td width="34%">
				<h2 align="right"><a href="mailto:michael.stevens@epost.de">michael.stevens@epost.de</a></h2>
			</td>
		</tr>
		<tr>
			<td colspan="2" width="57%" height="23" valign="top">
				<h2 align="right"><a href="http://www.acfr.usyd.edu.au/">Australian
				Centre for Field Robotics</a></h2>
			</td>
		</tr>
		<tr valign="top">
			<td width="43%">
				<h3><a href="ClassDocumentation/html/index.html">Documentation
				generated by Doxygen</a></h3>
				<blockquote><a href="ClassDocumentation/html/classBayesian__filter_1_1Bayes__filter__base.html">Filter
				hierarchy</a><br><a href="ClassDocumentation/html/classBayesian__filter_1_1Predict__model__base.html">Prediction
				models</a> and <a href="ClassDocumentation/html/classBayesian__filter_1_1Observe__model__base.html">Observation
				models</a><br><br><a href="ClassDocumentation/html/functions.html">Class
				members</a> and <a href="ClassDocumentation/html/files.html">File
				list of Bayes++</a> 
				</blockquote>
			</td>
			<td colspan="2" width="57%">
				<h2 align="right"><a href="http://lists.sourceforge.net/lists/listinfo/bayesclasses-general">Bayes++
				Mailing List</a></h2>
				<h3 align="right"><a name="download"></a><a href="http://sourceforge.net/projects/bayesclasses/">Project
				Summary</a> and <a href="http://sourceforge.net/project/showfiles.php?group_id=54729">Download</a></h3>
				<p align="right"><a name="CVS_Repository"></a><img src="http://sourceforge.net/sflogo.php?group_id=54729&amp;type=5" name="Grafik1" alt="SourceForge Logo" align="top" width="120" height="40" border="0">
				<a href="http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/bayesclasses">CVS
				Repository</a><br>
Bayes++ uses the <a href="http://www.boost.org/" target="_top">Boost</a><br>
peer-reviewed
				portable C++ source libraries</p></td>
		</tr>
	</tbody></table>
</center>

<p align="left"><br>Bayesian Filtering is a probabilistic technique for
data fusion. The technique combines a concise mathematical
formulation of a system with observations of that system.
Probabilities are used to represent the state of a system, likelihood
functions to represent their relationships. In this form Bayesian
inference can be applied and further related probabilities deduced.
See <a href="http://www.wikipedia.org/">Wikipedia</a> for information
on <a href="http://www.wikipedia.org/wiki/Probability_theory">Probability
theory</a>, <a href="http://www.wikipedia.org/wiki/Bayes%27_theorem">Bayes
theorem</a>, <a href="http://www.wikipedia.org/wiki/Bayesian_inference">Bayesian
Inference</a>.</p>

<p align="left">For <u>discrete</u> systems the Bayesian formulation
results in a naturally iterative data fusion solution. For <u>dynamic</u>
systems there is a class of solutions, discrete <u>filters</u>, that
combine observed inputs to the system with the dynamic model . A
filter that iteratively incorporates new information is an <u>estimator</u>.
For linear dynamic systems, discrete solutions such as the Kalman
filter apply.</p>

<p align="left">Bayes++ is an open source library of C++ classes. These
classes represent and implement a wide variety of numerical
algorithms for Bayesian Filtering of discrete systems. The classes
provide tested and consistent numerical methods and the class
hierarchy explicitly represents the variety of filtering algorithms
and system model types.</p>

<h2>Simple
Example</h2>

<p>This is very simple example; for those who have never used the
Bayesian Filtering Classes before. If you wish to see how simple it
is to use Bayes++ then <a href="Simple/simpleExample.cpp">View the
Source</a>.</p>

<p>The example shows how two classes are created. The first is the
prediction model, the second the observation model. In this example
they represent a simple linear problem with only one state variable
and constant model noises. A filter fuses the results of prediction
and observation.</p>

<p>Compiling the Examples</p>

<p>First <a href="#download">download</a> and extract <b>Bayes++</b>
and also the <b>Boost</b> library. <b>Boost</b> is used to provide
compiler independence, and a common build system. Two Boost header
libraries are used: <b>uBLAS</b> for linear algebra, and <b>random</b>
for the PV and QuadCalib examples. The Boost headers can be placed
anywhere relative to Bayes++, but it is easy if you follow this
structure:</p>

<dl>
<dl><dt><em>...sourceDirectory</em> 
		</dt><dl><dt>
			Bayes++ 
			</dt><dl><dt>
				BayesFilter 
				</dt><dt>
				PV 
				</dt><dt>
				QuadCalib 
				</dt><dt>
				Simple 
				</dt><dt>
				Test</dt></dl><dt>
			boost-1.30.2 
			</dt><dl><dt>
				boost 
				</dt><dt>
				<i>etc</i></dt></dl></dl></dl>
</dl>

<p>
Using the Boost Build system is the best way to compile the examples.
This uses the <b>bjam</b> (Boost jam) program to compute dependencies
and invoke the compiler. The documentation in your downloaded copy of
Boost explains how to obtain bjam and the sources to compile it
yourself. For everything to work <b>bjam</b> must be placed in the
path. <br>To build Bayes++ and the examples simply execute: (Bayes++
should be the current directory)</p>

<pre>        <font face="Verdana, Arial, Sans-Serif">bjam -s"BOOST_ROOT=../boost-1.30.2"</font></pre>
<p>
If there is more then one toolsets (compiler etc) available you may
want to tell bjam which to use. For example to use Visual C++ 7
execute:</p>

<pre>        <font face="Verdana, Arial, Sans-Serif">bjam -sTOOLS="vc7" -s"BOOST_ROOT=../boost-1.30.2"</font></pre>
<p>
It is possible to drop the BOOST_ROOT variable by either creating a
<b>build_build.jam</b> file in <i>sourceDirectory</i> (or above) or
by setting it as an environment variable. A simple Makefile also
exists to encapsulate the bjam build commands.</p>

<h4>Location of
compiled examples and libraries</h4>

<p>The executables for the three examples will be placed inside a
directory hierarchy named <b>target</b>. Static libraries for debug
and release builds of the <b>BayesFilter</b> library are placed in
<b>target/lib</b>. The <b>target </b>directory and its subdirectories
are created automatically. See the <a href="./Bayesian%20Filtering%20Classes.html">Bayesian
Filtering classes</a> overview for a description of the classes and
all three examples. 
</p>

<h4>Visual C++
solution</h4>

<p>For Visual C++ 7 you can also use the <b>Bayes++.sln</b> solution
and the active configuration <b>uBLAS Debug</b>. The compiler options
must be set so the <b>Boost</b> include files can be found. That is,
the <u>include path</u> must contain the base directory of Boost. In
this case the <b>boost-1.30.2</b> directory. In VC7 you should do
this by choosing the <i>Tools/Options/Projects/VC++ Directories</i>
option.</p>

<h2>Licensing</h2>

<p>All Bayes++ source code files are copyright with the license
conditions as given here. The copyright notice is that of the MIT
license. This in no way restricts any commercial use you may wish to
make using our source code. As long as you respect the copyright and
license conditions, Michael Stevens and the Australian Centre for
Field Robotics are happy to for you to use it in any way you wish.</p>

<h2>Terms
and conditions of use</h2>

<p>Bayes++ the Bayesian Filtering Library</p>

<p>Copyright (c) 2003 Michael Stevens, Copyright &copy; 2002 Michael
Stevens and Australian Centre for Field Robotics</p>

<p>Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation files
(the "Software"), to deal in the Software without
restriction, including without limitation the rights to use, copy,
modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished
to do so, subject to the following conditions:</p>

<p>The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.</p>

<p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF
ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.</p>

<h2>SLAM
: Simultaneous Localization and Mapping</h2>

<p>SLAM is one of the most interesting problems in Bayesian
filtering. It's structure implies that it cannot be correctly solved
without using stochastic approach. This is due to mapped states being
dependent on other mapped states and the localization state. This
dependence also make the problem complex, therefore a simple approach
such as representing all correlations is not tractable for large
numbers of states.</p>

<p>Bayes++ has been used to implement various simple and some more
advanced SLAM solutions. In particular a full implementation of
FastSLAM has been implemented. This technique is described in the
paper "FastSLAM : Factored Solution to the Simultaneous
Localization and Mapping Problem", M. Montemerlo, S. Thrun S, D.
Koller, B. Wegbreit, Proceedings of the AAAI National Conference on
Artificial Intelligence 2002.</p>

<p>The Bayes++ implementation of FastSLAM and a very simple Kalman
(full correlation) SLAM implementation is available as part of the
most recent <a href="#download">download</a>.</p>

<h2>Scilab,
Matlab, MuPAD</h2>

<p>These mathematical tools are particularly useful for visualising
filtering results. However they are all rather slow, and it is very
easy to produce very poorly implemented filters in their programming
languages. Fortunately all these tools provide mechanisms for
extension with external programs. Example interface code is provided
in the <a href="#CVS_Repository">Bayes++ CVS repository</a> for
Matlab and MuPAD. An interface to Scilab is not yet available.</p>

<h2>Portability</h2>

<p>Bayes++ only makes use of ISO standard C++. The source code uses
moderately advance C++ constructs. It only makes restricted use of
the C++ template system directly. However the Boost libraries used
(in particular uBLAS) make extensive use of template techniques.
Boost also includes many workarounds for compiler deficiencies.
Therefore with few alterations Bayes++ should work with any modern
C++ compiler supported by Boost.</p>

<p>Bayes++ is compatible with: <b>GCC 3.2</b>, <b>GCC 2.95.3</b>,
<b>VisualC++ 7 (.NET)</b> and <b>IntelC++ 7.1</b></p>

<p>Later versions of GCC 3.x.y should also run Bayes++ with ease.
However GCC 3.3.0 is know to be incompatible with uBLAS and to
produce incorrect code with -O2 optimization.</p>

<p>Previously Bayes++ was compatible with Visual C++6, but new
releases have not been tested. Be aware that VC6 can get very
confused! Particular when complex templates compiled. The order that
headers are included can be important. Similarly VC7 often requires
the /Zm option to be used so it can compile complex headers.</p>

<h2><a name="ReleaseCriteria"></a>Release
Criteria</h2>

<p>Releases are validated with above four compilers using the
following tests. 
</p>

<ol>

	<li><p>Build system: Compatibility with both Boost Build version 1
	and version 2.<br>Successfully complete &#8220;bjam&#8221; to build
	default libraries and examples.<br>Successfully complete &#8220;bjam&#8221;
	to build SLAM system.<br>Successfully build with VC7 from
	&#8220;Bayes++.sln&#8221;.</p>
	</li><li><p>Test examples: simpleExample, PV, QuadCalib <br>Compile debug
	and release builds (using Boost Build version 2) :- with no errors
	and no warnings.<br>Execution output :- Identical to expected
	reference results.<br><i>As of Boost-1.31.0 PV and QuadCalib are
	excluded from tests with gcc 2.95.3 as it is no able to compile the
	new Boost.Random.</i></p>
	</li><li><p>Numerical tests: rtheta - Range angle observer.<br>A
	non-linear range angle observer test. The observer moves in a 2
	dimensional state space. Motion prediction occurs with a linear
	model with additive noise. The two states are coupled both in the
	model and in addative noise. Range and angle of a fixed target is
	observed. The target is placed so discontinues angles are
	observed.<br>Both the state and the observations have additional non
	observed (singular) states. Model sizes, coupling parameters and
	model types can be varied for additional tests. All schemes are
	tested over 5 iterations of the model. The SIR scheme is tested with
	1000 samples.<br>Because the different numerical implementations
	results are not expected to be identical between Schemes. Therefore
	testing requires:<br>Regression testing :- Changed in output for any
	Scheme from the previous release.<br>Consistency testing :-
	Comparison of the output for Scheme pairs know to produce
	numerically similar results.<br>Test with gcc 2.95.3 is not possible
	as it is no able to compile Boost.Format.</p>
	</li><li><p>SLAM test: testFastSLAM<br>Consistency testing :- Comparison
	of FastSLAM result with 1,000,000 samples with Kalman SLAM.
	Deviations of state and covariance expected to be approx 1/1000th.</p>
</li>
</ol>

<h2>FAQ</h2>

<p><a href="Bayes++FAQ.html" name="FAQ">Follow
this link for an up to the separate Bayes++ FAQ</a>.</p>


<h2><a name="whatsnew"></a>What's
new in Bayes++ 2003-8?</h2>

<h3>Compiler
support</h3>

<p>The list of compiler for which Bayes++ is built and tested has
been extended. It is validated for GCC 3.2, GCC 2.95.3, Visual C++
7.0, and Intel C++ 7.1</p>

<h3>New
Boost Support</h3>

<p>Jens Mauer has been working hard on getting <b>boost::random</b>
accepted as part of the future C++ standard library. To this end
there have been substantial changes to its interface. These have now
be committed to Boost CVS. The Bayes++ examples make use of
boost::random. So things migrate smoothly I have added a new
"test/random.hpp" header which hides the interface changes.</p>

<p>The very excellent <b>Boost Build system version 2 </b>has
advanced a great deal recently. Bayes++ is built with standard Boost
Build system. To select the version 2 build system, simply use "bjam
--v2". Bayes++ has all the necessary "Jamfiles.v2" to
use the new system.</p>

<h3>Scheme
extensions</h3>

<p>The UD_scheme observe functions have had their numerical
capabilities extended. It is now possible to work with singular (zero
variance) covariance matrices.</p>

<p>The Unscented_scheme has additional function init_XX() and
update_XX() to allow access to an Unscented state representation.</p>

<h3>Numeric
fixes</h3>

<p>An error in <i>SIR_kalman_schemes</i> covariance calculation has
been fixed. This error also effected the <i>Fast_kalman_SLAM</i>
implementation. The error was significant for small small sizes.</p>

<h2>What's
new in Bayes++ 2003-5?</h2>

<h3>'noalias'
assignment</h3>

<p>For efficiency it is important to avoid creating temporary matrix
and vector copies. Unless told otherwise it is not possible for <b>uBLAS
</b>to determine if the same matrix or vector variable is specified
on both the left and right hand side of an assignment operation. If
such variable does appear it is said to be an <i>alias</i>. Because
assignment involves more then one element, the presence of an alias
requires that an assignment first compute a temporary result before
the aliased variable is modified.</p>

<p><b>uBLAS</b>'s default behavior is to create such a temporary. If
the assignment is know to be free of an alias this should be avoided.
Previously such an optimized assignment was specified with the
<b>.assign()</b> member functions. To improve the readability of code
I have added a new syntax for assignment. Where no aliases of
variable assigned to (lvalue) appears in the expression on the right
hand side of the assignment use:</p>

<pre> <font face="Verdana, Arial, Sans-Serif">noalias(lvalue) = expression;</font></pre>
<p>
This new syntax is experimental but will probably be part of a future
<b>uBLAS</b> release. At present the implementation introduces a
small overhead on the supported compilers. This includes GCC 3.2.</p>

<h2>What's
new in Bayes++ 2003-3?</h2>

<h3>Filters are named <i>_filter</i>, Schemes are named <i>_scheme</i></h3>

<p>Abstract filters and numeric schemes previously all had names
ending in <i>_filter</i>. To make things simpler the naming has been
changed to make a clear separation in what is a two level hierarchy.</p>

<p>Filters lie at the base of the hierarchy. Schemes are always
derived from one of more filters. Filters represent abstract
concepts, such as the statistics of state representation and model
interface. Schemes are concrete implementations of a filter with all
the numeric details and interfaces completed.</p>

<p>As part of this change the statistics of state representation have
been made <b>virtual base classes</b>. This change is designed to
allow multiple schemes combined together (using multiple inheritance)
and share their representation. The change adds a little more work if
you choose to derive from a scheme class. The constructors for the
derived class must call the constructors for the virtual base classes
directly.</p>

<h3>Covariance
Intersect Scheme added</h3>

<p>Finally the <b>CI</b> algorithm has been implemented as a Scheme
in Bayes++. CI is interesting as it provides a weaker but more robust
fusion then traditional covariance based method such as the Kalman
filter. It estimates state and an upper bound of what its covariance
could be.<br><br>Actually only the matrix algebra associated with CI
has is included. The CI_filter scheme provides a virtual function
where the user must define the actual optimization algorithm to be
used.</p>

<h3>Importance
Resampling infrastructure added</h3>

<p>The flexibility of the <i>SIR_filter </i>has been greatly
improved. A new class <i>Importance_resampler</i> has been added.
Whenever <i>SIR_filter </i>need to re-sample it uses and
Importance_resampler parameter. Therefore by changing this parameter,
different re-samplers can be used. 
</p>

<p>Two implementation are provided. The <i>Standard_resampler</i> and
the <i>Systematic_resampler</i>. See the referenced publications for
further discussion of these methods.</p>

<h3>Gappy
Matrices</h3>

<p>The matrix interface has been further improved. These improvement
require uBLAS from boost_1_30_0. With this version there is now
experimental support for using uBLAS <b>gappy</b> matrices and
vectors (sparse, compressed, coordinate).</p>

<p>The experimental support makes all of Bayes++ use a selected uBLAS
storage type. Check <b>matSupSub.hpp </b>for macro's required to
enable this. The algorithms used is Bayes++ are being upgraded to
perform better with sparse types.</p>

<p>The mult_SPD products are no longer supported. They are replaced
with the prod_SPD interface.</p>

<h3><a name="References1"></a>Copyright</h3>

<p align="left">Copyright (c) 2003 Michael Stevens. This document is
part of the Bayes++ library - see licensing section for copyright
license details.</p>

</body></html>