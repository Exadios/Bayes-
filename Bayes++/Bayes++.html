<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=utf-8">
	<TITLE>Bayes++ Bayesian Filtering</TITLE>
	<META NAME="GENERATOR" CONTENT="OpenOffice.org 1.1.0  (Linux)">
	<META NAME="CREATED" CONTENT="20040212;11525200">
	<META NAME="CHANGED" CONTENT="20040216;12160400">
	<LINK REL="stylesheet" HREF="Deployment/paper.css" TYPE="text/css">
</HEAD>
<BODY LANG="en-US" DIR="LTR">
<H1 ALIGN=CENTER><U>Bayes++</U></H1>
<H1 ALIGN=CENTER>Open Source Bayesian Filtering Classes</H1>
<CENTER>
	<TABLE WIDTH=93% BORDER=5 CELLPADDING=2 CELLSPACING=3 BGCOLOR="#c0c0c0">
		<COL WIDTH=111*>
		<COL WIDTH=59*>
		<COL WIDTH=86*>
		<TR VALIGN=TOP>
			<TD ROWSPAN=2 WIDTH=43%>
				<H2><A HREF="./Bayesian Filtering Classes.html">Bayesian
				Filtering</A></H2>
				<P>Overview of Bayesian filtering with the Filtering Classes 
				</P>
			</TD>
			<TD WIDTH=23% HEIGHT=15>
				<H2 ALIGN=LEFT>Michael Stevens</H2>
			</TD>
			<TD WIDTH=34%>
				<H2 ALIGN=RIGHT><A HREF="mailto:michael.stevens@epost.de">michael.stevens@epost.de</A></H2>
			</TD>
		</TR>
		<TR>
			<TD COLSPAN=2 WIDTH=57% HEIGHT=23 VALIGN=TOP>
				<H2 ALIGN=RIGHT><A HREF="http://www.acfr.usyd.edu.au/">Australian
				Centre for Field Robotics</A></H2>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=43%>
				<H3><A HREF="ClassDocumentation/html/index.html">Documentation
				generated by Doxygen</A></H3>
				<BLOCKQUOTE><A HREF="ClassDocumentation/html/classBayesian__filter_1_1Bayes__filter__base.html">Filter
				hierarchy</A><BR><A HREF="ClassDocumentation/html/classBayesian__filter_1_1Predict__model__base.html">Prediction
				models</A> and <A HREF="ClassDocumentation/html/classBayesian__filter_1_1Observe__model__base.html">Observation
				models</A><BR><BR><A HREF="ClassDocumentation/html/functions.html">Class
				members</A> and <A HREF="ClassDocumentation/html/files.html">File
				list of Bayes++</A> 
				</BLOCKQUOTE>
			</TD>
			<TD COLSPAN=2 WIDTH=57%>
				<H2 ALIGN=RIGHT><A HREF="http://lists.sourceforge.net/lists/listinfo/bayesclasses-general">Bayes++
				Mailing List</A></H2>
				<H3 ALIGN=RIGHT><A NAME="download"></A><A HREF="http://sourceforge.net/projects/bayesclasses/">Project
				Summary</A> and <A HREF="http://sourceforge.net/project/showfiles.php?group_id=54729">Download</A></H3>
				<P ALIGN=RIGHT><A NAME="CVS_Repository"></A><IMG SRC="http://sourceforge.net/sflogo.php?group_id=54729&amp;type=5" NAME="Grafik1" ALT="SourceForge Logo" ALIGN=TOP WIDTH=120 HEIGHT=40 BORDER=0>
				<A HREF="http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/bayesclasses">CVS
				Repository</A><BR>Bayes++ uses the <A HREF="http://www.boost.org/" TARGET="_top">Boost</A><BR>peer-reviewed
				portable C++ source libraries</P>
			</TD>
		</TR>
	</TABLE>
</CENTER>
<P ALIGN=LEFT><BR>Bayesian Filtering is a probabilistic technique for
data fusion. The technique combines a concise mathematical
formulation of a system with observations of that system.
Probabilities are used to represent the state of a system, likelihood
functions to represent their relationships. In this form Bayesian
inference can be applied and further related probabilities deduced.
See <A HREF="http://www.wikipedia.org/">Wikipedia</A> for information
on <A HREF="http://www.wikipedia.org/wiki/Probability_theory">Probability
theory</A>, <A HREF="http://www.wikipedia.org/wiki/Bayes'_theorem">Bayes
theorem</A>, <A HREF="http://www.wikipedia.org/wiki/Bayesian_inference">Bayesian
Inference</A>.</P>
<P ALIGN=LEFT>For <U>discrete</U> systems the Bayesian formulation
results in a naturally iterative data fusion solution. For <U>dynamic</U>
systems there is a class of solutions, discrete <U>filters</U>, that
combine observed inputs to the system with the dynamic model . A
filter that iteratively incorporates new information is an <U>estimator</U>.
For linear dynamic systems, discrete solutions such as the Kalman
filter apply.</P>
<P ALIGN=LEFT>Bayes++ is an open source library of C++ classes. These
classes represent and implement a wide variety of numerical
algorithms for Bayesian Filtering of discrete systems. The classes
provide tested and consistent numerical methods and the class
hierarchy explicitly represents the variety of filtering algorithms
and system model types.</P>
<H2>Simple Example</H2>
<P>This is very simple example; for those who have never used the
Bayesian Filtering Classes before. If you wish to see how simple it
is to use Bayes++ then <A HREF="Simple/simpleExample.cpp">View the
Source</A>.</P>
<P>The example shows how two classes are created. The first is the
prediction model, the second the observation model. In this example
they represent a simple linear problem with only one state variable
and constant model noises. A filter fuses the results of prediction
and observation.</P>
<P>Compiling the Examples</P>
<P>First <A HREF="#download">download</A> and extract <B>Bayes++</B>
and also the <B>Boost</B> library. <B>Boost</B> is used to provide
compiler independence, and a common build system. Two Boost header
libraries are used: <B>uBLAS</B> for linear algebra, and <B>random</B>
for the PV and QuadCalib examples. The Boost headers can be placed
anywhere relative to Bayes++, but it is easy if you follow this
structure:</P>
<DL>
	<DL>
		<DT><EM>...sourceDirectory</EM> 
		</DT><DL>
			<DT>
			Bayes++ 
			</DT><DL>
				<DT>
				BayesFilter 
				</DT><DT>
				PV 
				</DT><DT>
				QuadCalib 
				</DT><DT>
				Simple 
				</DT><DT>
				Test</DT></DL>
			<DT>
			boost_1_31_0 
			</DT><DL>
				<DT>
				boost 
				</DT><DT STYLE="margin-bottom: 0.5cm">
				<I>etc</I></DT></DL>
		</DL>
	</DL>
</DL>
<P>
Using the Boost Build system version 2 is the best way to compile the
examples. This uses the <B>bjam</B> (Boost jam) program to compute
dependencies and invoke the compiler. The documentation in your
downloaded copy of Boost explains how to obtain compile the latest
version of bjam yourself. For everything to work <B>bjam</B> must be
placed in the path. <BR>To build Bayes++ and the examples simply
execute: (Bayes++ should be the current directory)</P>
<PRE STYLE="margin-bottom: 0.5cm">        bjam –v2 -s&quot;BOOST_ROOT=../boost_1_31_0&quot;</PRE><P>
If there is more then one toolsets (compiler etc) available you may
want to tell bjam which to use. For example to use Visual C++
execute:</P>
<PRE STYLE="margin-bottom: 0.5cm">        bjam –v2 msvc -s&quot;BOOST_ROOT=../boost_1_31_0&quot;</PRE><P>
It is possible to drop the BOOST_ROOT variable by either creating a
<B>build_build.jam</B> file in <I>sourceDirectory</I> (or above) or
by setting it as an environment variable.</P>
<H4>Location of compiled examples and libraries</H4>
<P>The executables for the three examples will be placed inside a
directory hierarchy named <B>target</B>. Static libraries for debug
and release builds of the <B>BayesFilter</B> library are placed in
<B>target/lib</B>. The <B>target </B>directory and its subdirectories
are created automatically. See the <A HREF="./Bayesian Filtering Classes.html">Bayesian
Filtering classes</A> overview for a description of the classes and
all three examples. 
</P>
<H4>Visual C++ solution</H4>
<P>For Visual C++ 7 you can also use the <B>Bayes++.sln</B> solution
and the active configuration <B>uBLAS Debug</B>. The compiler options
must be set so the <B>Boost</B> include files can be found. That is,
the <U>include path</U> must contain the base directory of Boost. In
this case the <B>boost_1_31_0</B> directory. In VC7 you should do
this by choosing the <I>Tools/Options/Projects/VC++ Directories</I>
option.</P>
<H2>Licensing</H2>
<P>All Bayes++ source code files are copyright with the license
conditions as given here. The copyright notice is that of the MIT
license. This in no way restricts any commercial use you may wish to
make using our source code.</P>
<H2>Terms and conditions of use</H2>
<P>Bayes++ the Bayesian Filtering Library</P>
<P>Copyright (c) 2003,2004 Michael Stevens, Copyright &copy; 2002
Michael Stevens and Australian Centre for Field Robotics</P>
<P>Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation files
(the &quot;Software&quot;), to deal in the Software without
restriction, including without limitation the rights to use, copy,
modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished
to do so, subject to the following conditions:</P>
<P>The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.</P>
<P>THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF
ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.</P>
<H2>Gappy Matrices</H2>
<P>uBLAS supports a variety of 'gappy' matrix types. Sparse,
Compressed, and Coordinate matrices are all available from within the
standard uBLAS interface.</P>
<P>Bayes++ has a limited form of support for using these uBLAS gappy
matrix forms. This experimental support makes <U>all</U> of Bayes++
use a selected uBLAS matrix type. Check <B>matSupSub.hpp </B>for
macro's required to enable this. The algorithms used is Bayes++ are
being upgraded to perform better with gappz types.</P>
<H2>Importance Resampling infrastructure</H2>
<P>The <I>SIR_</I>filter scheme provides the infrastructure for
implementing a variety of resampled filters. The flexibility is
provided by the class hierarchy <I>Importance_resampler</I>. Whenever
<I>SIR_filter </I>need to re-sample it a specified
<I>Importance_resampler</I> parameter is available. Therefore by
changing this parameter, different re-samplers can be used. 
</P>
<P>Two implementation are provided. The <I>Standard_resampler</I> and
the <I>Systematic_resampler</I>. See the referenced publications for
further discussion of these methods.</P>
<H2>SLAM : Simultaneous Localization and Mapping</H2>
<P>SLAM is one of the most interesting problems in Bayesian
filtering. It's structure implies that it cannot be correctly solved
without using stochastic approach. This is due to mapped states being
dependent on other mapped states and the localization state. This
dependence also make the problem complex, therefore a simple approach
such as representing all correlations is not tractable for large
numbers of states.</P>
<P>Bayes++ has been used to implement various simple and some more
advanced SLAM solutions. In particular a full implementation of
FastSLAM has been implemented. This technique is described in the
paper &quot;FastSLAM : Factored Solution to the Simultaneous
Localization and Mapping Problem&quot;, M. Montemerlo, S. Thrun S, D.
Koller, B. Wegbreit, Proceedings of the AAAI National Conference on
Artificial Intelligence 2002.</P>
<P>The Bayes++ implementation of FastSLAM and a very simple Kalman
(full correlation) SLAM implementation is available as part of the
most recent <A HREF="#download">download</A>.</P>
<H2>Scilab, Matlab, MuPAD</H2>
<P>These mathematical tools are particularly useful for visualising
filtering results. However they are all rather slow, and it is very
easy to produce very poorly implemented filters in their programming
languages. Fortunately all these tools provide mechanisms for
extension with external programs. Example interface code is provided
in the <A HREF="#CVS_Repository">Bayes++ CVS repository</A> for
Matlab and MuPAD. An interface to Scilab is not yet available.</P>
<H2><A NAME="Portability|outline"></A>Portability</H2>
<P>Bayes++ only makes use of ISO standard C++. The source code uses
moderately advance C++ constructs. It only makes restricted use of
the C++ template system directly. However the Boost libraries used
(in particular uBLAS) make extensive use of template techniques.
Boost also includes many workarounds for compiler deficiencies.
Therefore with few alterations Bayes++ should work with any modern
C++ compiler supported by Boost.</P>
<P>This release of Bayes++ is tested with: <B>Boost 1.31.0</B></P>
<P>This release Bayes++ is tested with: <B>GCC 3.3.1</B>, <B>GCC 3.4</B>,
<B>VisualC++ 7 (.NET)</B> and <B>IntelC++ 7.1</B></P>
<P>Later versions of GCC 3.x.y should also run Bayes++ with ease.
However GCC 3.3.0 is know to be incompatible with uBLAS and to
produce incorrect code with -O2 optimization.</P>
<P>Previously Bayes++ was compatible with Visual C++6, but new
releases have not been tested. Be aware that VC6 can get very
confused! Particular when complex templates compiled. The order that
headers are included can be important. Similarly VC7 often requires
the /Zm option to be used so it can compile complex headers.</P>
<H2><A NAME="ReleaseCriteria"></A>Release Criteria</H2>
<P>Releases are validated using the compilers and Boost versions
listed above using the following tests. 
</P>
<OL>
	<LI><P>Build system: Compatibility with both Boost Build version 1
	and version 2.<BR>Successfully complete “bjam” to build default
	libraries and examples.<BR>Successfully complete “bjam” to build
	SLAM system.<BR>Successfully build with VC7 from “Bayes++.sln”.</P>
	<LI><P>Test examples: simpleExample, PV, QuadCalib <BR>Compile debug
	and release builds (using Boost Build version 2) :- with no errors
	and no warnings.<BR>Execution output :- Identical to expected
	reference results.</P>
	<LI><P>Numerical tests: rtheta - Range angle observer.<BR>A
	non-linear range angle observer test. The observer moves in a 2
	dimensional state space. Motion prediction occurs with a linear
	model with additive noise. The two states are coupled both in the
	model and in additive noise. Range and angle of a fixed target is
	observed. The target is placed so discontinues angles are
	observed.<BR>Both the state and the observations have additional non
	observed (singular) states. Model sizes, coupling parameters and
	model types can be varied for additional tests. All schemes are
	tested over 5 iterations of the model. The SIR scheme is tested with
	1000 samples.<BR>Because the different numerical implementations
	results are not expected to be identical between Schemes. Therefore
	testing requires:<BR>Regression testing :- Changed in output for any
	Scheme from the previous release.<BR>Consistency testing :-
	Comparison of the output for Scheme pairs know to produce
	numerically similar results.</P>
	<LI><P>SLAM test: testFastSLAM<BR>Consistency testing :- Comparison
	of FastSLAM result with 1,000 samples with Kalman SLAM. Deviations
	of state and covariance expected to be approx 1 in sqrt(1000).</P>
</OL>
<H2>FAQ – Frequently Asked Questions</H2>
<P><A HREF="Bayes++FAQ.html" NAME="FAQ">Follow this link for an up to
the separate Bayes++ FAQ</A>.</P>
<H2><A NAME="whatsnew1"></A>What's new in Bayes++
2004.2-experimental?</H2>
<P>The list of compiler for which Bayes++ is built and tested has
been updated. See <A HREF="#Portability|outline">Portability</A>.</P>
<H2><A NAME="whatsnew"></A>What's new in Bayes++ 2003-8?</H2>
<H3>Compiler support</H3>
<P>The list of compiler for which Bayes++ is built and tested has
been extended. It is validated for GCC 3.2, GCC 2.95.3, Visual C++
7.0, and Intel C++ 7.1</P>
<H3>New Boost Support</H3>
<P>Jens Mauer has been working hard on getting <B>boost::random</B>
accepted as part of the future C++ standard library. To this end
there have been substantial changes to its interface. These have now
be committed to Boost CVS. The Bayes++ examples make use of
boost::random. So things migrate smoothly I have added a new
&quot;test/random.hpp&quot; header which hides the interface changes.</P>
<P>The very excellent <B>Boost Build system version 2 </B>has
advanced a great deal recently. Bayes++ is built with standard Boost
Build system. To select the version 2 build system, simply use &quot;bjam
--v2&quot;. Bayes++ has all the necessary &quot;Jamfiles.v2&quot; to
use the new system.</P>
<H3>Scheme extensions</H3>
<P>The UD_scheme observe functions have had their numerical
capabilities extended. It is now possible to work with singular (zero
variance) covariance matrices.</P>
<P>The Unscented_scheme has additional function init_XX() and
update_XX() to allow access to an Unscented state representation.</P>
<H3>Numeric fixes</H3>
<P>An error in <I>SIR_kalman_schemes</I> covariance calculation has
been fixed. This error also effected the <I>Fast_kalman_SLAM</I>
implementation. The error was significant for small small sizes.</P>
<H2><A NAME="References1"></A>Copyright</H2>
<P ALIGN=LEFT>Copyright (c) 2003,2004 Michael Stevens. This document
is part of the Bayes++ library - see licensing section for copyright
license details.</P>
</BODY>
</HTML>