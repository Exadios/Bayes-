<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=utf-8">
	<TITLE>Bayes++ Bayesian Filtering</TITLE>
	<LINK REL="stylesheet" HREF="Deployment/paper.css" TYPE="text/css">
</HEAD>
<H1 ALIGN=CENTER><U>Bayes++</U></H1>
<H1 ALIGN=CENTER><B>Open Source Bayesian Filtering Classes</B></H1>
<H2 ALIGN=CENTER>Michael Stevens</H2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<CENTER>
	<TABLE WIDTH=100% BORDER=5 CELLPADDING=0 CELLSPACING=4 BGCOLOR="#c0c0c0">
		<TR VALIGN=TOP>
			<TD WIDTH=368 HEIGHT=48>
				<H2><A HREF="Bayesian Filtering Classes.html">Bayesian Filtering</A></H2>
				<P>Overview of Bayesian filtering with the Filtering Classes
				</P>
			</TD>
			<TD WIDTH=330>
				<H2 ALIGN=RIGHT><A HREF="mailto:michael.stevens@epost.de">Michael.Stevens@epost.de</A></H2>
				<H2 ALIGN=RIGHT><A HREF="http://www.acfr.usyd.edu.au/">Australian
				Centre for Field Robotics</A></H2>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=368>
				<H3><A HREF="ClassDocumentation/html/index.html">Documentation
				generated by Doxygen</A></H3>
				<BLOCKQUOTE><A HREF="ClassDocumentation/html/classBayesian__filter_1_1Bayes__filter__base.html">Filter
				hierarchy</A><BR><A HREF="ClassDocumentation/html/classBayesian__filter_1_1Predict__model__base.html">Prediction
				models</A> and <A HREF="ClassDocumentation/html/classBayesian__filter_1_1Observe__model__base.html">Observation
				models</A><BR><BR><A HREF="ClassDocumentation/html/functions.html">Class
				members</A> and <A HREF="ClassDocumentation/html/files.html">File
				list of Bayes++</A>
				</BLOCKQUOTE>
			</TD>
			<TD WIDTH=330>
				<H3 ALIGN=RIGHT><A NAME="download"></A><A HREF="http://sourceforge.net/projects/bayesclasses/">Project
				Summary</A> and <A HREF="http://sourceforge.net/project/showfiles.php?group_id=54729">Download</A></H3>
				<P ALIGN=RIGHT><A NAME="CVS_Repository"></A><IMG SRC="http://sourceforge.net/sflogo.php?group_id=54729&amp;type=5" NAME="Grafik1" ALT="SourceForge Logo" ALIGN=TOP WIDTH=120 HEIGHT=40 BORDER=0>
				<A HREF="http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/bayesclasses">CVS
				Repository</A><BR>Bayes++ uses the <A HREF="http://www.boost.org/" TARGET="_top"><FONT SIZE=5>Boost</FONT></A><BR>peer-reviewed
				portable C++ source libraries</P>
			</TD>
		</TR>
	</TABLE>
</CENTER>
<P ALIGN=LEFT>
      Bayesian Filtering is a probabilistic technique for data fusion. The technique combines a concise mathematical formulation of a system with observations of that system. Probabilities are used to represent the state of a system, likelihood functions to represent their relationships. In this form Bayesian inference can be applied and further related probabilities deduced. See <A HREF="http://www.wikipedia.org/">Wikipedia</A> for information on <A HREF="http://www.wikipedia.org/wiki/Probability_theory">Probability
theory</A>, <A HREF="http://www.wikipedia.org/wiki/Bayes'_theorem">Bayes
theorem</A>, <A HREF="http://www.wikipedia.org/wiki/Bayesian_inference">Bayesian
Inference</A>.</P>
<P ALIGN=LEFT>For <U>discrete</U> systems the Bayesian formulation
results in a naturally iterative data fusion solution. For <U>dynamic</U>
systems there is a class of solutions, discrete <U>filters</U>, that combine observed outputs of the system with the system's dynamic model. An <U>estimator</U> computes a estimate of the systems state with each observation
of the system. Linear estimators such as the Kalman Filter are commonly applied.</P>
<P ALIGN=LEFT>Bayes++ is an open source library of C++ classes. These
classes represent and implement a wide variety of numerical
algorithms for Bayesian Filtering of discrete systems. The classes
provide tested and consistent numerical methods and the class
hierarchy explicitly represents the variety of filtering algorithms
and system model types.</P>
<H2>Simple Example</H2>
<P>This is very simple example; for those who have never used the
Bayesian Filtering Classes before. If you wish to see how simple it
is to use Bayes++ then <A HREF="Simple/simpleExample.cpp">View the
Source</A>.</P>
<P>The example shows how two classes are created. The first is the
prediction model, the second the observation model. In this example
they represent a simple linear problem with only one state variable
and constant model noises. A filter fuses the results of prediction
and observation.</P>
<P>Compiling the Examples</P>
<P>First <A HREF="#download">download</A> and extract <B>Bayes++</B>
and also the <B>Boost</B> library. <B>Boost</B> is used to provide
compiler independence, and a common build system. Two Boost header
libraries are used: <B>uBLAS</B> for linear algebra, and <B>random</B>
for the PV and QuadCalib examples. The Boost headers can be placed
anywhere relative to Bayes++, but it is easy if you follow this
structure:</P>
<DL>
	<DD><DL>
		<DT><EM>...sourceDirectory</EM></DT>
		<DD><DL>
			<DT>Bayes++</DT>
				<DD>BayesFilter</DD>
				<DD>PV</DD>
				<DD>QuadCalib</DD>
				<DD>Simple</DD>
				<DD>Test</DD>
		</DL></DD>
		<DD><DL>
			<DT>boost_1_32_0 <I>(or boost_1_31_0)</I></DT>
				<DD>boost</DD>
				<DD><I>etc</I></DD>
		</DL></DD>
	</DL></DD>
</DL>
<P>
Using the Boost Build system is the best way to compile the examples.
This uses the <B>bjam</B> (Boost jam) program to compute dependencies
and invoke the compiler. The documentation in your downloaded copy of
Boost explains how to obtain bjam and the sources to compile it
yourself. For everything to work <B>bjam</B> must be placed in the
path. <BR>To build Bayes++ and the examples simply execute: (Bayes++
should be the current directory)</P>
<PRE STYLE="margin-bottom: 0.5cm">        bjam -sBOOST_ROOT=&quot;../boost_1_32_0&quot;</PRE><P>
If there is more then one toolsets (compiler etc) available you may
want to tell bjam which to use. For example to use Visual C++ 7.1
execute:</P>
<PRE STYLE="margin-bottom: 0.5cm">        bjam -sTOOLS=vc-7_1 -sBOOST_ROOT=&quot;../boost_1_32_0&quot;</PRE><P>
It is possible to drop the BOOST_ROOT variable by either creating a
<B>bin/lib</B>. The <B>bin </B>directory and its subdirectories are
created automatically. See the <A HREF="Bayesian Filtering Classes.html">Bayesian
Filtering classes</A> overview for a description of the classes and
all three examples.
</P>
<H4>Visual C++ solution</H4>
<P>For Visual C++ 7.1 you can also use the <B>Bayes++.sln</B> solution
and the active configuration <B>uBLAS Debug</B>. The compiler options
must be set so the <B>Boost</B> include files can be found. That is,
the <U>include path</U> must contain the base directory of Boost. In
this case the local <B>boost</B> directory. In VC7.1 you should do
this by choosing the <I>Tools/Options/Projects/VC++ Directories</I>
option.</P>
<H2>Licensing</H2>
<P>All Bayes++ source code files are copyright with the license
conditions as given here. The copyright notice is that of the MIT
license. This in no way restricts any commercial use you may wish to
make using our source code. As long as you respect the copyright and
license conditions, Michael Stevens and the Australian Centre for
Field Robotics are happy to for you to use it in any way you wish.</P>
<P>Bayes++ the Bayesian Filtering Library</P>
<P>Copyright (c) 2003,2004,2005 Michael Stevens, Copyright (c) 2002
Michael Stevens and Australian Centre for Field Robotics</P>
<P>Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation files
(the &quot;Software&quot;), to deal in the Software without
restriction, including without limitation the rights to use, copy,
modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished
to do so, subject to the following conditions:</P>
<P>The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.</P>
<P>THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF
ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.</P>
<H2>SLAM : Simultaneous Localization and Mapping</H2>
<P>SLAM is one of the most interesting problems in Bayesian
filtering. It's structure implies that it cannot be correctly solved
without using stochastic approach. This is due to mapped states being
dependent on other mapped states and the localization state. This
dependence also make the problem complex, therefore a simple approach
such as representing all correlations is not tractable for large
numbers of states.</P>
<P>Bayes++ has been used to implement various simple and some more
advanced SLAM solutions. In particular a full implementation of
FastSLAM has been implemented. This technique is described in the
paper &quot;FastSLAM : Factored Solution to the Simultaneous
Localization and Mapping Problem&quot;, M. Montemerlo, S. Thrun S, D.
Koller, B. Wegbreit, Proceedings of the AAAI National Conference on
Artificial Intelligence 2002.</P>
<P>The Bayes++ implementation of FastSLAM and a very simple Kalman
(full correlation) SLAM implementation is available as part of the
most recent <A HREF="#download">download</A>.</P>
<H2>Scilab, Matlab, MuPAD</H2>
<P>These mathematical tools are particularly useful for visualising
filtering results. However they are all rather slow, and it is very
easy to produce very poorly implemented filters in their programming
languages. Fortunately all these tools provide mechanisms for
extension with external programs. Example interface code is provided
in the <A HREF="#CVS_Repository">Bayes++ CVS repository</A> for
Matlab and MuPAD. An interface to Scilab is not yet available.</P>
<H2>Portability</H2>
<P>Bayes++ only makes use of ISO standard C++. The source code uses
moderately advance C++ constructs. It only makes restricted use of
the C++ template system directly. However the Boost libraries used
(in particular uBLAS) make extensive use of template techniques.
Boost also includes many workarounds for compiler deficiencies.
Therefore with few alterations Bayes++ should work with any modern
C++ compiler supported by Boost.</P>
<P>Bayes++ is tested with: <B>Boost 1.31.0</B> and <B>Boost 1.32.0</B></P>
<P>Bayes++ is tested with: <B>GCC 3.3.3</B>, <B>GCC 3.4.2</B>,
<B>VisualC++ 7.1</B> and <B>IntelC++ 8.1</B></P>
<P>Later versions of GCC 3.x and GCC 4.x should also run Bayes++ with ease.
However GCC 3.3.0 is know to be incompatible with uBLAS and to
produce incorrect code with -O2 optimization.</P>
<P>Previously Bayes++ was compatible with Visual C++6, but new
releases have not been tested. Be aware that VC6 can get very
confused! Particular when complex templates compiled. The order that
headers are included can be important. Similarly VC7.1 often requires
the /Zm option to be used so it can compile complex headers.</P>
<H2>Release Criteria</H2>
<P>This releases is validated using the compilers and Boost versions
listed above using the following tests.
</P>
<OL>
<LI><P>Build system: Compatibility with both Boost Build version 1
and version 2.<BR>Successfully complete �bjam� to build default
libraries and examples.<BR>Successfully complete �bjam�to build
SLAM system.<BR>Successfully build with VC7.1 from �Bayes++.sln�.</P>
<LI><P>Test examples: simpleExample, PV, QuadCalib <BR>Compile debug
and release builds (using Boost Build version 2) :- with no errors
and no warnings.<BR>Execution output :- Identical to expected
reference results.</P>
<LI><P>Numerical tests: rtheta - Range angle observer.<BR>A
non-linear range angle observer test. The observer moves in a 2
dimensional state space. Motion prediction occurs with a linear
model with additive noise. The two states are coupled both in the
model and in additive noise. Range and angle of a fixed target is
observed. The target is placed so discontinues angles are
observed.<BR>Both the state and the observations have additional non
observed (singular) states. Model sizes, coupling parameters and
model types can be varied for additional tests. All schemes are
tested over 5 iterations of the model. The SIR scheme is
tested with 1000 samples.<BR>Because the different numerical
implementations results are not expected to be identical between
Schemes. Therefore testing requires:<BR>Regression testing :-
Changed in output for any Scheme from the previous
release.<BR>Consistency testing :- Comparison of the output for
Scheme pairs know to produce numerically similar results.</P>
<LI><P>SLAM test: testFastSLAM<BR>Consistency testing :- Comparison
of FastSLAM result with 1,000,000 samples with Kalman SLAM.
Deviations of state and covariance expected to be approx 1/1000th.</P>
</OL>
<H2>FAQ</H2>
<H4>Does Bayes++ do Kalman Filtering?</H4>
<P>Yes, there are many Kalman filter implementations in Bayes++. In
Bayes++, the Kalman Filter and the Extended Kalman Filter (EKF) are
implemented by the <I>Covariance_filter</I> Scheme.</P>
<H4>How fast is Bayes++?</H4>
<P>Pretty quick! Depends on the filter Scheme used. The <I>UD_filter</I>
is smallest and fastest Scheme. The best way to speed things up is to
work on optimised use of uBLAS and to optimized uBLAS itself for you
compiler.</P>
<H4>What is a 'Scheme'?</H4>
<P>A 'Scheme' is the term used in Bayes++ to define a particular
numerical implementation of a filter. Each Scheme is based on one of
a few statistical representations of state. Different schemes work on
these statistics using different numerical techniques. The aim of
Bayes++ is to provides common interfaces to Schemes so you can pick
an choose which to use.</P>
<H4>Why should I use Bayes++? After all, writing a Kalman filter in
Matlab is not too hard.</H4>
<P>For a simple test this may be true. If you have ever tried to deal
with the wide variety of numerical failures and normalizations
required to deal with discontinues model, you will realize that there
is more to implementing a Kalman filter then a hand full of linear
algebra equations!</P>
<P>Many DIY Kalman filter implementations fail as they do not
maintain the symmetry of matrices. If this is problem is corrected,
they usually use numerically inaccurate algorithms and also will
silently continue to operate even when the results no longer make
sense. The matrices are ill conditioned! All these hard problems have
been solved for you by Bayes++.</P>
<P>However Bayes++ most powerful feature is <B>not</B> that it just
does things correctly! It provides a consistent methodology to apply
multiple Bayesian filtering techniques. Once you have codified the
models that represent a problem you can solve your problem with many
difference Bayesian filtering techniques. These may be simple linear
filters such as the <I>Information_filter</I> scheme, or even a
particle filter such as the <I>SIR_filter</I> scheme.</P>
<H4>Is Bayes++ stable?</H4>
<P>Although many things have been added to Bayes++ over the last two
years they have only added to the variety of implementations.
Bayes++'s interface has now reached a very mature stage with little
or no change required to add new Schemes. Be aware however that the
Matrix support implementation (anything in namespace
Bayesian_filter_matrix) may change to accommodate matrix library
changes.</P>
<P>The implementations of filtering Schemes included in the web
release, have all been tested with a standard range angle observation
problem. I also use the filtering Schemes for my own work, and so do
others at the <A HREF="http://www.acfr.usyd.edu.au/">Australian
Centre for Field Robotics</A> and all over the world.</P>
<H4>Do I need to program in C++ to use Bayes++?</H4>
<P>Yes! Bayes++ was developed to provide the maximum functionality in
C++. A good C++ text book will help you understand how Bayes++ works.
There is no need to learn C programming first. Learning C is not a
good introduction to modern C++ programming techniques used in
Bayes++. I would recommend Deitel and Deitel, &quot;C++: How to
Program&quot;, Second Edition, Prentice Hall, ISBN 0-13-528910-6. It
is an excellent beginners book; and includes many useful tips and a
thorough understanding of the language.</P>
<H4>Where are the PDFs?</H4>
<P>Bayes rule is usually defined in term of Probability Density
Functions. However PDFs never appear in Bayes++. They are always
represented by their statistics. &nbsp;This is for good reason, there
is very little that can be done algorithmically with such a function.
However the sufficient statistics, given the assumptions of a filter,
can be easily manipulated to implement Bayes rule. This is essential
what Kalman developed for linear systems.
</P>
<P>Each filter scheme is derived from one or more virtual base
classes that represent the statistics used. For example the
<I>Kalman_state_filter</I> and <I>Sample_filter</I> base classes.</P>
<H4>What Matrix library do you recommend?</H4>
<P>As of version 1_29_0 <A HREF="http://www.boost.org/"><B>Boost</B></A>
includes a public release of the <A HREF="http://www.boost.org/libs/numeric/ublas/doc/index.htm"><B>uBLAS</B></A>
library. This an excellent basic linear algebra library. The
interface and syntax are easy to use. It provides a wide variety of
matrix and vector containers and a complete set of Basic Linear
Algebra operations. The implementation and structure can incorporate
many future enhancements and efficiency improvements. The more I use
uBLAS the more I like it! See also my note on <A HREF="http://www.crystalclearsoftware.com/cgi-bin/boost_wiki/wiki.pl?Effective_UBLAS">Effective
uBLAS</A> on the Boost Wiki.</P>
<P>Credit for uBLAS goes to Joerg Walter and Mathias Koch. Many
thanks!</P>
<P>Older releases of Bayes++ support both uBLAS and <A HREF="http://www.osl.iu.edu/research/mtl/">MTL
the Matrix Template Library</A>. Future releases of MTL may also be
of interest to Bayes++. However at present nothing is being publicly
releases so I will await the outcome.</P>
<P>In principle it is possible to use a different matrix library when
Bayes++ is built. This just requires a new version of <I>matSubSup.hpp</I>
to be found before the one supplied in Bayes++ itself. However
Bayes++ makes extensive use of uBLAS syntax, so a change is a
significant task.</P>
<H2><A NAME="whatsnew"></A>What's new in Bayes++ 2003.8-4</H2>
<P>New Documentation and support for <B>Boost 1_32_0</B>.</P>
<P>Sample covariances are now computed using the definition for the Maximum Likelihood (biased) estimate. This estimate simply
devides by 1/n the number of samples, rather then 1/(n-1). See <A href="http://en.wikipedia.org/wiki/Bias_(statistics)"> Sample Statistics in Wikipedia</A>.</P>
<H3>Compiler support</H3>
<P>The list of compiler for which Bayes++ is built and tested has
been update.
<H2>Bayes++ 2003.8-3</H2>
<P>Corrects documentation and support for Boost Build (version 1).</P>
<P>SLAM has been updated from the current development version.</P>
<H3>Compiler support</H3>
<P>GCC 3.4 requires a couple
of <I>typename</I> fixes to uBLAS (Boost_1_31_0 or earlier).</P>
<H2>Bayes++ 2003.8-2</H2>
<H3>New Boost Support</H3>
<P>Bayes++ is tested with both <B>Boost-1.30.2</B> and <B>Boost_1_31_0</B>.
</P>
<P>Jens Mauer has been working hard on getting <B>boost::random</B>
accepted as part of the future C++ standard library. To this end
there have been substantial changes to its interface. The new library
is now part of Boost_1_31_0. The Bayes++ examples make use of
boost::random. So things migrate smoothly I have added a new
&quot;test/random.hpp&quot; header which hides the interface changes.</P>
<P>The very excellent <B>Boost Build system version 2 </B>has
advanced a great deal recently. Bayes++ is built with standard Boost
Build system. To select the version 2 build system, simply use &quot;bjam
--v2&quot;. Bayes++ has all the necessary &quot;Jamfiles.v2&quot; to
use the new system.</P>
<H3>Scheme extensions</H3>
<P>The UD_scheme observe functions have had their numerical
capabilities extended. It is now possible to work with singular (zero
variance) covariance matrices.</P>
<P>The Unscented_scheme has additional function init_XX() and
update_XX() to allow access to an Unscented state representation.</P>
<H3>Numeric fixes</H3>
<P>An error in <I>SIR_kalman_schemes</I> covariance calculation has
been fixed. This error also effected the <I>Fast_kalman_SLAM</I>
implementation. The error was significant for small small sizes.</P>
<H2>Bayes++ 2003-5</H2>
<H3>'noalias' assignment</H3>
<P>For efficiency it is important to avoid creating temporary matrix
and vector copies. Unless told otherwise it is not possible for <B>uBLAS
</B>to determine if the same matrix or vector variable is specified
on both the left and right hand side of an assignment operation. If
such variable does appear it is said to be an <I>alias</I>. Because
assignment involves more then one element, the presence of an alias
requires that an assignment first compute a temporary result before
the aliased variable is modified.</P>
<P><B>uBLAS</B>'s default behavior is to create such a temporary. If
the assignment is know to be free of an alias this should be avoided.
Previously such an optimized assignment was specified with the
<B>.assign()</B> member functions. To improve the readability of code
I have added a new syntax for assignment. Where no aliases of
variable assigned to (lvalue) appears in the expression on the right
hand side of the assignment use:</P>
<PRE STYLE="margin-bottom: 0.5cm"> noalias(lvalue) = expression;</PRE><P>
This new syntax is experimental but will probably be part of a future
<B>uBLAS</B> release. At present the implementation introduces a
small overhead on the supported compilers. This includes GCC 3.2.</P>
<H2>Bayes++ 2003-3</H2>
<H3>Filters are named <I>_filter</I>, Schemes are named <I>_scheme</I></H3>
<P>Abstract filters and numeric schemes previously all had names
ending in <I>_filter</I>. To make things simpler the naming has been
changed to make a clear separation in what is a two level hierarchy.</P>
<P>Filters lie at the base of the hierarchy. Schemes are always
derived from one of more filters. Filters represent abstract
concepts, such as the statistics of state representation and model
interface. Schemes are concrete implementations of a filter with all
the numeric details and interfaces completed.</P>
<P>As part of this change the statistics of state representation have
been made <B>virtual base classes</B>. This change is designed to
allow multiple schemes combined together (using multiple inheritance)
and share their representation. The change adds a little more work if
you choose to derive from a scheme class. The constructors for the
derived class must call the constructors for the virtual base classes
directly.</P>
<H3>Covariance Intersect Scheme added</H3>
<P>Finally the <B>CI</B> algorithm has been implemented as a Scheme
in Bayes++. CI is interesting as it provides a weaker but more robust
fusion then traditional covariance based method such as the Kalman
filter. It estimates state and an upper bound of what its covariance
could be.<BR><BR>Actually only the matrix algebra associated with CI
has is included. The CI_filter scheme provides a virtual function
where the user must define the actual optimization algorithm to be
used.</P>
<H3>Importance Resampling infrastructure added</H3>
<P>The flexibility of the <I>SIR_filter </I>has been greatly
improved. A new class <I>Importance_resampler</I> has been added.
Whenever <I>SIR_filter </I>need to re-sample it uses and
Importance_resampler parameter. Therefore by changing this parameter,
different re-samplers can be used.
</P>
<P>Two implementation are provided. The <I>Standard_resampler</I> and
the <I>Systematic_resampler</I>. See the referenced publications for
further discussion of these methods.</P>
<H3>Gappy Matrices</H3>
<P>The matrix interface has been further improved. These improvement
require uBLAS from boost_1_30_0. With this version there is
experimental support for using uBLAS <B>gappy</B> matrices and
vectors (sparse, compressed, coordinate).</P>
<P>The experimental support makes all of Bayes++ use a selected uBLAS
storage type. Check <B>matSupSub.hpp </B>for macro's required to
enable this. The algorithms used is Bayes++ are being upgraded to
perform better with sparse types.</P>
<P>The mult_SPD products are no longer supported. They are replaced
with the prod_SPD interface.</P>
<H3><A NAME="References1"></A>Copyright</H3>
<P ALIGN=LEFT>Copyright (c) 2003, 2004, 2005 Michael Stevens. This document is
part of the Bayes++ library - see licensing section for copyright
license details.</P>
</BODY>
</HTML>
