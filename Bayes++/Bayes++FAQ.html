<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"><html><head>
  
  <meta http-equiv="CONTENT-TYPE" content="text/html; charset=iso-8859-1">
  <title>Bayes++ FAQ</title>

  
  
  <link href="Deployment/paper.css" type="text/css" rel="Stylesheet">

  
  <meta name="author" content="Michael Stevens">
</head>

<body lang="en-US">
<h1 align="center"><u>Bayes++ FAQ</u></h1>


<h1 align="center"><b>Open Source Bayesian Filtering Classes</b></h1>


<h2 align="center">Michael Stevens</h2>


<h4>Does Bayes++ do Kalman Filtering?</h4>


<p>Yes, there are many Kalman filter implementations in Bayes++. In
Bayes++, the Kalman Filter and the Extended Kalman Filter (EKF) are
implemented by the <i>Covariance_filter</i> Scheme.</p>


<h4>How fast is Bayes++?</h4>


<p>Pretty quick! Depends on the filter Scheme used. The <i>UD_filter</i>
is smallest and fastest Scheme. The best way to speed things up is to
work on optimised use of uBLAS and to optimized uBLAS itself for you
compiler.</p>


<h4>What is a 'Scheme'?</h4>


<p>A 'Scheme' is the term used in Bayes++ to define a particular
numerical implementation of a filter. Each Scheme is based on one of
a few statistical representations of state. Different schemes work on
these statistics using different numerical techniques. The aim of
Bayes++ is to provides common interfaces to Schemes so you can pick
an choose which to use.</p>


<h4>Why should I use Bayes++? After all, writing a Kalman filter in
Matlab is not too hard.</h4>


<p>For a simple test this may be true. If you have ever tried to deal
with the wide variety of numerical failures and normalizations
required to deal with discontinues model, you will realize that there
is more to implementing a Kalman filter then a hand full of linear
algebra equations!</p>


<p>Many DIY Kalman filter implementations fail as they do not
maintain the symmetry of matrices. If this is problem is corrected,
they usually use numerically inaccurate algorithms and also will
silently continue to operate even when the results no longer make
sense. The matrices are ill conditioned! All these hard problems have
been solved for you by Bayes++.</p>


<p>However Bayes++ most powerful feature is <b>not</b> that it just
does things correctly! It provides a consistent methodology to apply
multiple Bayesian filtering techniques. Once you have codified the
models that represent a problem you can solve your problem with many
difference Bayesian filtering techniques. These may be simple linear
filters such as the <i>Information_filter</i> scheme, or even a
particle filter such as the <i>SIR_filter</i> scheme.</p>


<h4>Is Bayes++ stable?</h4>


<p>Although many things have been added to Bayes++ over the last two
years they have only added to the variety of implementations.
Bayes++'s interface has now reached a very mature stage with little
or no change required to add new Schemes. Be aware however that the
Matrix support implementation (anything in namespace
Bayesian_filter_matrix) may change to accommodate matrix library
changes.</p>


<p>The implementations of filtering Schemes included in the web
release, have all been tested with a standard range angle observation
problem. I also use the filtering Schemes for my own work, and so do
others at the <a href="http://www.acfr.usyd.edu.au/">Australian
Centre for Field Robotics</a> and all over the world.</p>


<h4>Do I need to program in C++ to use Bayes++?</h4>


<p>Yes! Bayes++ was developed to provide the maximum functionality in
C++. A good C++ text book will help you understand how Bayes++ works.
There is no need to learn C programming first. Learning C is not a
good introduction to modern C++ programming techniques used in
Bayes++. I would recommend Deitel and Deitel, "C++: How to
Program", Second Edition, Prentice Hall, ISBN 0-13-528910-6. It
is an excellent beginners book; and includes many useful tips and a
thorough understanding of the language.</p>


<h4>Where are the PDFs?</h4>


<p>Bayes rule is usually defined in term of Probability Density
Functions. However PDFs never appear in Bayes++. They are always
represented by their statistics. &nbsp;This is for good reason, there
is very little that can be done algorithmically with such a function.
However the sufficient statistics, given the assumptions of a filter,
can be easily manipulated to implement Bayes rule. This is essential
what Kalman developed for linear systems. 
</p>


<p>Each filter scheme is derived from one or more virtual base
classes that represent the statistics used. For example the
<i>Kalman_state_filter</i> and <i>Sample_filter</i> base classes.</p>


<h4>What Matrix library do you recommend?</h4>


<p>As of version 1_29_0 <a href="http://www.boost.org/"><b>Boost</b></a>
includes a public release of the <a href="http://www.boost.org/libs/numeric/ublas/doc/index.htm"><b>uBLAS</b></a>
library. This an excellent basic linear algebra library. The
interface and syntax are easy to use. It provides a wide variety of
matrix and vector containers and a complete set of Basic Linear
Algebra operations. The implementation and structure can incorporate
many future enhancements and efficiency improvements. The more I use
uBLAS the more I like it! See also my note on <a href="http://www.crystalclearsoftware.com/cgi-bin/boost_wiki/wiki.pl?Effective_UBLAS">Effective
uBLAS</a> on the Boost Wiki.</p>


<p>Credit for uBLAS goes to Joerg Walter and Mathias Koch. Many
thanks!</p>


<p>Older releases of Bayes++ support both uBLAS and <a href="http://www.osl.iu.edu/research/mtl/">MTL
the Matrix Template Library</a>. Future releases of MTL may also be
of interest to Bayes++. However at present nothing is being publicly
releases so I will await the outcome.</p>


<p>In principle it is possible to use a different matrix library when
Bayes++ is built. This just requires a new version of <i>matSubSup.hpp</i>
to be found before the one supplied in Bayes++ itself. However
Bayes++ makes extensive use of uBLAS syntax, so a change is a
significant task.</p>


</body></html>