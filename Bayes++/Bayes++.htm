<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
  <title>Bayes++ Bayesiean Filtering Classes</title>
                                                                        
                                         
  <link media="all" href="/style.css" type="text/css" rel="Stylesheet">
</head>
  <body>
                                               
<h1 align="center"><u>Bayes++</u></h1>
       
<h1 align="center"><b>Open Source Bayesian Filtering Classes</b></h1>
                     
<div align="center">           
<h2>Michael Stevens</h2>
           </div>
                     
<div>			                          </div>
           <br>
                        		                        
<div>			                        
<table height="203" cellpadding="0" align="center" border="5"
 cellspacing="4" bgcolor="#c0c0c0" width="100%">
                          <tbody>
                            <tr>
                              <td valign="top" width="368" height="48">							
                                                                        
                                                                        
                                                                   
      <h2><a href="Bayesian%20Filtering%20Classes.htm">Bayesian Filtering</a></h2>
                              Overview of Bayesian filtering with the Filtering 
   Classes           </td>
                              <td valign="top" width="330" height="48">							
                                                                        
                                                                        
                                                                   
      <h2 align="right"><a href="mailto:michael.stevens@epost.de">michael.stevens@epost.de</a></h2>
                                                                        
                                                                        
                                                                        
      <h2 align="right"><a href="http://www.acfr.usyd.edu.au">Australian Center
for Field Robotics</a></h2>
                              </td>
                            </tr>
                            <tr>
                              <td valign="top" width="368">							      
                                                                        
                                                                        
                                                                       
      <h3><a href="ClassDocumentation/html/index.html">Documentation generated 
     by Doxygen</a></h3>
                                                                        
                      
      <blockquote dir="ltr" style="margin-right: 0px;"> <a
 href="ClassDocumentation/html/classBayesian__filter_1_1Bayes__filter__base.html">Filter 
       hierarchy</a><br>
                <a
 href="ClassDocumentation/html/classBayesian__filter_1_1Predict__model__base.html">Prediction 
       models</a> and <a
 href="ClassDocumentation/html/classBayesian__filter_1_1Observe__model__base.html">Observation 
       models</a><br>
                <br>
                <a href="ClassDocumentation/html/functions.html">Class members</a>
     and         <a href="ClassDocumentation/html/files.html">File list of
 Bayes++</a>            </blockquote>
               </td>
                              <td valign="top" width="330">							      
                                                                        
                                                                        
                                                                        
                                                                   
      <h3 align="right"><a name="download"></a><a
 href="http://sourceforge.net/projects/bayesclasses/">Project Summary</a>
            and <a
 href="http://sourceforge.net/project/showfiles.php?group_id=54729">Download</a></h3>
                                                                        
                                                                        
                                                                        
      <p align="right"><img alt="SourceForge Logo"
 src="http://sourceforge.net/sflogo.php?group_id=54729&amp;amp;type=5"
 border="0">
 <a name="CVS_Repository"></a><a
 href="http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/bayesclasses">CVS Repository</a> 
                            </p>
                                                                        
                                                                        
                                                                        
      <p align="right">Bayes++ uses the <a href="http://www.boost.org"
 target="_top">       <big><big>Boost</big></big>       </a><br>
                        peer-reviewed portable C++ source libraries</p>
                              </td>
                            </tr>
                        				                                            
                                                                        
          
  </tbody>                        
</table>
                        </div>
                        		  		                        
<p align="justify">Bayesian Filtering is a probabilistic technique for data
fusion. The technique             combines a concise mathematical formulation
of a system with observations             of that system. Probabilities are
used to represent the state of   a  system,       likelihood functions to
represent their relationships.  In  this  form Bayesian     inference can
be applied and further related probabilities    deduced. See   <a
 href="http://www.wikipedia.org/">Wikipedia</a> for information    on <a
 href="http://www.wikipedia.org/wiki/Probability_theory">Probability    theory</a>,
     <a href="http://www.wikipedia.org/wiki/Bayes%27_theorem">Bayes theorem</a>, 
           <a href="http://www.wikipedia.org/wiki/Bayesian_inference">Bayesian 
     Inference</a>.</p>
                                             
<p align="justify">For <u>discrete</u> systems the Bayesian formulation results
in a naturally             iterative data fusion solution. For <u>dynamic</u>
systems there    is   a  class    of solutions, discreate <u>filters</u>,
that combine observed       inputs  to  the  system with the dynamic model
. A filter that iteratively       incorporates    new  information is an
<u>estimator</u>. For linear dynamic      systems, discrete     solutions
such as the Kalman filter apply.</p>
                                               
<p align="justify">Bayes++ is an open source library of C++ classes. These
classes represent   and implement          a wide variety of numerical algorithms
for Bayesian   Filtering of discrete         systems. The classes provide
tested and consistent   numerical methods    and    the class hierarchy explicitly
represents the   variety of filtering    algorithms     and system model
types.</p>
                        		                        
<h2>Simple Example</h2>
                        		                        
<p>This is very simple example; for those who have never used the Bayesian
            Filtering Classes before. If you wish, <a
 href="simpleExample.cpp">View      the  Source</a> online</p>
                        		                        
<p>The example shows how two classes are created. The first is the prediction
            model, the second the observation model. In this example they
represent          a  simple linear problem with only one state variable
and constant   model      noises.  A filter fuses the results of prediction
and observation.</p>
                        				                        
<h2>Compiling the Examples</h2>
                        		                        
<p>First <a href="#download">download</a> and extract <b>Bayes++</b> and also
the <b>Boost</b> library. <b>Boost</b> is used to provide compiler independence,
            and a common build system. Two Boost header libraries are used:
  <b>uBlas</b>          for linear algebra, and <b>random</b> for the PV
and   QuadCalib examples.         The Boost headers can be placed anywhere
relative   to Bayes++, but it   is   easy  if you follow this structure:</p>
                        		                        
<dl>
  <dl>
    <dt><em>...sourceDirectory</em> </dt>
    <dl>
      <dt>Bayes++            </dt>
      <dl>
        <dt>BayesFilter</dt>
        <dt>PV</dt>
        <dt>QuadCalib</dt>
        <dt>Simple</dt>
      </dl>
      <dt>boost_1_30_0&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;<i>The first version
           of Boost to include uBlas was boost_1_29_0</i></dt>
      <dl>
        <dt>boost</dt>
        <dt><i>etc</i><br>
             </dt>
      </dl>
    </dl>
  </dl>
</dl>
                        		                        
<p>Using the Boost Build system is the best way to compile the examples. This
uses the <b>bjam</b> (Boost jam) program to compute dependencies and invoke
the compiler.&nbsp; The documentation in your downloaded copy of Boost explains
how to obtain bjam and the sources    to compile it yourself. For everything
to work <b>bjam</b> must be placed in the path. <br>
                   To build Bayes++ and the examples simply execute: (make
 sure   you   are   in  the Bayes++ directory)<br>
                  </p>
                                   
<blockquote>                                                      
  <pre>bjam -s"BOOST_ROOT=../boost_1_30_0"<br></pre>
                  </blockquote>
                                   
<p>If there is more then one toolset (compiler etc) available you may want
         to tell bjam which to use. For example to use Visual C++ 7 execute:<br>
                  </p>
                                   
<blockquote>                                                         
  <pre>bjam -sTOOLS="vc7" -s"BOOST_ROOT=../boost_1_30_0"<br></pre>
                   </blockquote>
                                     
<p>It is possible to drop the BOOST_ROOT variable by either creating a "build_build.jam"
         file in <i>sourceDirectory</i> (or above) or by setting it as an
enviroment         variable. A simple Makefile also exists to encapsulate
the bjam build     commands.<br>
                  </p>
                  The executable for each example will be placed inside a 
directory      <i>target</i>      that will be created.<br>
                                               
<p>For Visual C++ 7 you can also use the <strong>Bayes++.sln</strong> solution
            and the active configuration <strong>uBLAS Debug</strong>. The
 compiler         options  must be set so the additional <em>Boost</em> include
 files   can    be  found. In this case the <u>include path</u> must contain
 the base  directory      of Boost. In this case the <strong>boost_1_30_0</strong>
  directory,  In   VC7   you should do this by using <em>Tools/Options/Projects/VC++
  Directories<br>
</em></p>
<h2>SLAM : Simultaneous Localization and Mapping</h2>
<p>SLAM is one of the most interesting problems in Bayesian filtering. It's
struture implies that it cannot be correctly solved without using stochastic
approach. This is due to mapped states being dependant on other mapped states
and the localization state. This dependance also make the problem complex,
therefore a simple approach such as representing all correlations is not
tractable for large numbers of states.<br>
</p>
<p>Bayes++ has been used to implement various simple and some more advanaced
SLAM solutions. In particular a full implementation of FastSLAM has implemented.
This is described in the paper "FastSLAM : Factored Solution to the Simultaneous
Localization and Mapping Problem",&nbsp; Montemerlo, M. and Thrun, S. and
Koller, D. and Wegbreit, B. Proceedings of the AAAI National Conference on
Artificial Intelligence&nbsp; 2002.</p>
<p>The Bayes++ implemention of FastSLAM and a very simple Kalman (full correlation)
SLAM implementation is availabe from with the most recent <a
 href="#download">download</a>.<br>
</p>
                        		                        
<h2>Licensing</h2>
                        		                        
<p>All Bayes++ source code files are copyright with the licence conditions
            as given here. The copyright notice is that of the MIT license.
  This     in   no  way restricts any commercial use you may wish to make
using  our    source   code.  As long as you respect the copyright and license
conditions,      Michael   Stevens  and the Australian Centre for Field Robotics
are happy to for you to use it in any  way    you wish.</p>
                        		                        
<p>Bayes++ the Bayesian Filtering Library</p>
                        		                        
<p>Copyright (c) 2002 Michael Stevens and Australian Centre for Field Robotics</p>
                        		                        
<p>Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
            to deal in the Software without restriction, including without
 limitation           the rights to use, copy, modify, merge, publish, distribute,
 sublicense,          and/or sell copies of the Software, and to permit persons
 to whom  the    Software    is furnished to do so, subject to the following
 conditions:</p>
                        		                        
<p>The above copyright notice and this permission notice shall be included
            in all copies or substantial portions of the Software.</p>
                        		                        
<p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
            OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
            FITNESS FOR A PARTICULAR PURPOSE AND NON INFRINGEMENT. IN NO
EVENT      SHALL      THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES     OR OTHER     LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE,      ARISING   FROM,  OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE  OR   OTHER DEALINGS   IN  THE SOFTWARE.</p>
                        		                        
<h2>Portability</h2>
                        		                        
<p>Bayes++ only makes use of ISO standard C++. The source code uses moderately
            advance C++ constructs but only restricted use of the C++ template
     system.       The Boost libraries used make extensive use of template
 techniques    but    also   include many workarounds for compiler deficiencies.
 Therefore    with    few alterations   Bayes++ should work with any modern
 C++ compiler    supported    by Boost</p>
                        		                        
<p>General testing is performed with GCC 3.x and 2.95.3. It is generally
compatible Visual C++   7 (.NET) and Visual C++6, but new releases have not
tested. Be aware that VC6 can get very confused. Particular when complex
templates the   order that headers are included can be important. &nbsp;Similarly
VC7 often   requires the /Zm option to be used so it can compile complex
headers.<br>
                        </p>
                                               
<p><strong></strong></p>
                                   
<h2>FAQ</h2>
                        		                        
<h4>Does Bayes++ do Kalman Filtering?</h4>
                        		                        
<p>Yes, there are many Kalman filter implementations in Bayes++. In Bayes++, 
  the Kalman Filter and the Extended Kalman Filter (EKF) are implemented by
  the <em>Covariance_filter</em>          Scheme.</p>
                        		                        
<h4>How fast is Bayes++?</h4>
                        		                        
<p>Pretty quick! Depends on the filter Scheme used. The <i>UD_filter</i>
is smallest and fastest Scheme. The best way to speed things up is to work
on optimised use of uBlas and to optimized uBlas itself for you compiler.<br>
     </p>
         
<h4>What is a 'Scheme'?</h4>
         
<p>A 'Scheme' is the term used in Bayes++ to define a particular numerical 
  implemention of a filter. Each Scheme is based on one of a few statistical 
  representations of state. Different schemes work on these statistics using 
  different numerical techniques. The aim of Bayes++ is to provides common 
 interfaces to Schemes so you can pick an choose which to use.</p>
         
<h4>Why should I use Bayes++? After all, writting a Kalman filter in Matlab
            is not too hard.</h4>
                        		                        
<p>For a simple test this may be true. If you have ever tried to deal with
            the wide variety of numerical failures and normalisations required
     to   deal    with discontinues model you will realises that there is
more  to implementing       a  Kalman filter then a hand full of linear algebra 
  equations!</p>
                        		                        
<p>Many DIY Kalman filter implementations fail as they do not maintain the
            symmetry of matrices. If this is problem is corrected, they usually
      use    numerically  inaccurate algorithms and also will silently continue
      to operate    even when  the results no longer make sense. The matrices
    are  ill conditioned!    All these  hard problems have been solved for
 you   by Bayes++.</p>
                        		                        
<p>However Bayes++ most powerful feature is <strong>not</strong> that it just
does things correctly! It provides a consistent methodology to apply multiple
Bayesian filtering techniques. Once you have codified the models that represent
a problem you can solve your problem with many difference Bayesian filtering
techniques. These may be simple linear filters such as the<em> Information_filter</em>
scheme, or even a particle filter such as the<em> SIR_filter</em> scheme.</p>
                        		                        
<h4>Is Bayes++ stable?</h4>
                        		                        
<p>Although many things have been added to Bayes++ over the last two years
            they have only added to the variety of implementations. Bayes++'s
    interface        has now reached a very mature stage with little or no
 change   required    to   add new Schemes.&nbsp;Be aware however  that the
   Matrix   support implementation (anything in namespace Bayesian_filter_matrix)
     may   change in the future.</p>
                        		                        
<p>The implementations of filtering Schemes included in the web release, have
all been tested with a standard range angle observation problem. I also use
the filtering Schemes for my own work, and so do others at the <a
 href="http://www.acfr.usyd.edu.au">Australian Center for Field Robotics</a> 
and all over the world.<br>
 </p>
                        		                        
<h4>Do I need to program in C++ to use Bayes++?</h4>
                        		                        
<p>Yes! Bayes++ was developed to provide the maximum functionality in C++.
            A good C++ text book will help you understand how Bayes++ works.
   There      is   no need to learn C programming first. Learning C is not
 a  good introduction         to modern C++ programming techniques used in
 Bayes++.   I would recommend       Deitel  and Deitel, "C++: How to Program",
 Second   Edition, Prentice Hall,      ISBN 0-13-528910-6.  It is an excellent
 beginners   book; and includes  many     useful tips and a thorough  understanding
 of   the language.</p>
                                              
<h4>Where are the PDFs?</h4>
                                             
<p>Bayes rule is usually defined in term of Probability Density Functions.
            However PDFs never appear in Bayes++. They are always represented
    by   their     statistics. &nbsp;This is for good reason, there is very
  little     that can    be done algorithmically with such a function. However
  the  sufficient     statistics,    given the assumptions of a filter, can
  be easily  manipulated     to implement    Bayes rule. This is essential
 what Kalman developed for linear systems. </p>
         
<p>Each filter scheme is derived from one or more virtual base classes   
 that represent    the statistics used. For example the <i>Kalman_state_filter</i> 
      and <i>Sample_filter</i>     base classes.</p>
                                               
<h4>What Matrix library do you recommend?</h4>
                                             
<p>As of version 1_29_0 <b><a href="http://www.boost.org">Boost</a></b> includes 
a public release of the <a
 href="http://www.boost.org/libs/numeric/ublas/doc/index.htm"><b>uBLAS</b></a>
         library.   This an excellent linear algebra&nbsp; library. The interface 
        and syntax  are easy to use. It provides a wide variety of matrix 
and    vector    containers  and a complete set of Basic Linear Algebra operations. 
    The implementation     and structure can incorporate many future enhancements 
     and efficiency improvements. The more I use uBLAS the more I like   
it! See also my note on <a
 href="http://www.crystalclearsoftware.com/cgi-bin/boost_wiki/wiki.pl?Effective_UBLAS">Effective 
uBLAS</a> on the Boost Wiki.</p>
                                               
<p>Credit for uBLAS goes to Joerg Walter and Mathias Koch. Many thanks!</p>
         
<p>Older releases of Bayes++ support both uBlas and <a
 href="http://www.osl.iu.edu/research/mtl/">MTL the Matrix Template Library</a>.
            Future releases of MTL may also be of interest to Bayes++. However
     at   present    nothing is being publicly releases so I will await the
  outcome.</p>
                                              
<p>                   By simply changing the compiler include paths new matrix
    libraries      can   be  used when Bayes++ is built. This just requires
  a  new version   of   <i>matSubSup.hpp</i>    to be found before the one
 supplied  in Bayes++   itself.</p>
                                             
<h2><a name="whatsnew"></a>Whats new?</h2>
                 
<h3>Filters are _filters, Schemes are _schemes<br>
         </h3>
         Abstract filters and numeric schemes previously all had names ending 
  in  <i>_filter</i>. To make things simpler the naming has been changed to
  make  a clear seperation in what is a two level hierarchy.<br>
       Filters lie at the base of the hierarchy. Schemes are always derived 
 from   one of more filters. Filters represent abstract concepts, such as 
the statistics of state   representation and model interface. Schemes are 
concreate implementations   of a filter with all the numeric details and interfaces
completed.<br>
   <br>
   As part of this change the statistics of state representation have been
 made <b>virtual base classes</b>. This change is designed to allow multiple
 schemes combined together (using multiple inheritance) and share their reperesntation. 
 The change adds a little more work if you choose to derive from a scheme 
class. The constructors for the derived class must call the constructors for
the virtual base classes directly.<br>
             
<h3>Covariance Intersect Scheme added</h3>
                        Finally the <b>CI</b> algorithm has been implemented
  as  a  Scheme    in  Bayes++.   CI is interesting as it provides a weaker
  but  more  robust   fussion  then traditional   covariance based method
such  as  the Kalman filter.   It estimates state and   an upper bound of
what its covariance  could be.<br>
                   <br>
                   Actually only the matrix algebra associated with CI has
 is  included.      The   CI_filter scheme provides a virtual function where 
 the  user must   define   the  actual optimisation algorithm to be used.<br>
                                           
<h3>Importance Resampling infrastructure added</h3>
                        The flexibility of the <i>SIR_filter </i>has been 
greatly     improved.      A  new  class <i>Importance_resampler</i> has been
added.    Whenever  <i>SIR_filter        </i>need to resample it uses and
Importance_resampler     parameter. Therefore        by changing this parameter
different resamplers     can be used. <br>
                        Two implementation are provided. The <i>Standard_resampler</i>
       and   the   <i>Systematic_resampler</i>.  See the referenced publications
       for further    dicussion of these methods.<br>
                                     
<h3>Gappy Matrices</h3>
                                     
<p>The matrix interface has been further improved. These improvment require 
         uBLAS from boost_1_30_0. With this version there is now experimantal 
    support     for using uBLAS <b>gappy</b> matrices and vectors (sparse, 
 compressed,    coordinate).<br>
                   </p>
                                     
<p> The experimental support makes all of Bayes++ use a selected uBLAS storage 
         type. Check <b>matSupSub.hpp </b>for macro's required to enable this.
        The algorithms used is Bayes++ are being upgraded to perform better
  with     sparse types.<br>
                    </p>
                                     
<p> The mult_SPD products are no longer supported. They are replaced with 
         the prod_SPD interface.<br>
                   </p>
                                   
<h3>Matrix Interface changes included from 2002.10</h3>
               
<p>This release only supplies a matrix abstraction layer for Boost uBlas. 
   The change reflects my wish to change the Bayes++ matrix syntax to  more 
  closely reflect that of uBlas. There are a few simple changes to  note:</p>
               
<ol>
                          <li> nrows() and ncols() are now size1() and size2()
     </li>
                          <li> set(X, 0.) should be replaced by X.clear() 
for   any   container      type     </li>
                          <li> The operator* overloading is dropped. Use
the   explict     X  =  prod(A,B)<br>
                        uBlas a has a wide variety of different product.
Expression      complexity      can  be controlled by introducing a temporary.
For example          <i>prod&lt;type&gt;(A,B)</i>       can be used to compute
the product      of A,B where the type is used to hold     the temporary
result.</li>
                          <li> Look out for the use of X.assign(EE). This 
is  an  optimised      assignment    (instead of =) when the result of the 
expression    EE is independant     of X</li>
                          <li>The type Subscript has been removed. All interfaces 
    now   use       <b>size_t</b>    instead<br>
                          </li>
                                             
</ol>
                                              
<h3>size_t may be different type from Subscript</h3>
                                            
<p>The effective type change from <strong>unsigned</strong>         to<strong>size_t</strong>.
    This will only have an effect on a 64bit   or   any   platform where
these     two types have a different size.<br>
           </p>
                       <br>
          <br>
           <br>
           <br>
</body>
</html>
