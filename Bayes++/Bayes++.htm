<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
  <title>Bayes++ Bayesiean Filtering Classes</title>
                                                         		             
                                           
  <link media="all" href="http://www.acfr.usyd.edu.au/style.css"
 type="text/css" rel="Stylesheet">
</head>
<body>
<h1 align="center"><u>Bayes++ Bayesian Filter Classes</u></h1>
		
<div>			
<table height="203" cellpadding="0" align="center" border="5"
 cellspacing="4" bgcolor="#c0c0c0">
  <tbody>
    <tr>
      <td valign="top" width="368" height="48">							                  
                         
      <h2><a href="Bayesian%20Filtering%20Classes.htm">Bayesian Filtering</a></h2>
      Overview of Bayesian filtering with the Filtering Classes </td>
      <td valign="top" width="330" height="48">							                  
                         
      <h2 align="right"><a href="mailto:michael@acfr.usyd.edu.au">michael@acfr.usyd.edu.au</a></h2>
                           
      <h2 align="right"><a href="http://www.acfr.usyd.edu.au">Australian Center
for Field Robotics</a></h2>
      </td>
    </tr>
    <tr>
      <td valign="top" width="368">							                              
                          
      <p>Doxumentation generated by Doxygen.<br>
      <a href="ClassDocumentation/html/index.html"> View the structure of
Bayes++</a></p>
                           
      <blockquote dir="ltr" style="margin-right: 0px;">	<a
 href="ClassDocumentation/html/hierarchy.html" target="_top">Class hierarchy
of Bayes++</a><br>
        <a href="ClassDocumentation/html/functions.html" target="_top">Class
member of Bayes++</a><br>
        <a href="ClassDocumentation/html/files.html" target="_top">File List
of Bayes++</a>     </blockquote>
      </td>
      <td valign="top" width="330">							                              
                                                                        
                     
      <h3 align="right"><a name="download"></a><a
 href="http://sourceforge.net/projects/bayesclasses/">Project Summary</a>
and <a
 href="http://sourceforge.net/project/showfiles.php?group_id=54729">Download</a></h3>
                           
      <p align="right"><img alt="SourceForge Logo"
 src="http://sourceforge.net/sflogo.php?group_id=54729&amp;amp;type=5"
 border="0"></p>
                           
      <p align="right">Bayes++ uses the <big><a
 href="http://www.boost.org" target="_top">Boost</a></big><br>
peer-reviewed portable C++ source libraries</p>
      </td>
    </tr>
				                                                         
  </tbody>
</table>
</div>
		
<p>Bayesian Filtering is a probabilistic technique for data fusion. The technique
combines a concise mathematical formulation of a system with observations
of that system. Probabilities are used to represent the state of a system,
likelihood functions to represent their relationships. In this form Bayes
rule can be applied and further related probabilities deduced.</p>
		
<p>For <u>discrete</u> systems the Bayesian formulation results in a naturally
iterative data fusion solution. For <u>dynamic</u> systems there is a class
of solutions, discreate <u>filters</u>, that combine observed inputs to the
system with the dynamic model . A filter that iteratively incorporates new
information is an <u>estimator</u>. For linear dynamic systems, discrete solutions
such as the Kalman filter apply.</p>
<p>Bayes++ is a library of C++ classes. These classes represent and implement
a wide variety of numerical algorithms for Bayesian Filtering of discrete
systems. The classes provide tested and consistent numerical methods and
the class hierarchy explicitly represents the variety of filtering algorithms
and system model types.</p>
		
<h2>Simple Example</h2>
		
<p>This is very simple example; for those who have never used the Bayesian
Filtering Classes before. If you wish, <a href="simpleExample.cpp">View the
Source</a> online</p>
		
<p>The example shows how two classes are created. The first is the prediction
model, the second the observation model. In this example they represent a
simple linear problem with only one state variable and constant model noises.
A filter fuses the results of prediction and observation.</p>
				
<h2>Compiling the Examples</h2>
		
<p>First <a href="#download">download</a> and extract <b>Bayes++</b> and also
the <b>Boost</b> library. <b>Boost</b> is used to provide compiler independence,
and a common build system. Two Boost header libraries are used: <b>uBlas</b>
for linear algebra, and <b>random</b> for the PV and QuadCalib examples.
The Boost headers can be placed anywhere relative to Bayes++, but it is easy
if you follow this structure:</p>
		
<dl>
  <dl>
    <dt><em>...sourceDirectory</em> </dt>
    <dl>
      <dt>						                                             Bayes++    
 </dt>
      <dl>
        <dt>								                                                    
BayesFilter 	</dt>
        <dt>PV         </dt>
        <dt>										                                                  
QuadCalib 	</dt>
        <dt>											                                                 
Simple 	</dt>
      </dl>
      <dt>boost_1_29_0&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<i>The first version
of Boost to include uBlas</i></dt>
      <dl>
        <dt>boost</dt>
      </dl>
    </dl>
  </dl>
</dl>
		
<p>Using the Boost Build system is the best way to compile the examples. This
uses the <b>bjam</b> (Boost jam) program to compute dependencies and invoke
the compiler. To make things simpler a simple Makefile exists that will set
everything up and then begin the build process using Boost Build. &nbsp;For
this to work <b>bjam</b> must be placed in the path. The documentation in
your downloaded copy of Boost explains how to obtain bjam and the sources
to compile it yourself.<br>
Therefore to build all the examples simply use:<br>
</p>
<blockquote>make				  for GCC tools<br>
nmake TOOLS='msvc'     for Visual C++ 6<br>
nmake TOOLS='vc7'        for Visual C++ 7<br>
</blockquote>
The executable for each examples will be placed inside a directory <i>bin</i>
that will be created.<br>
<p>For Visual C++ 7 you can also use the <strong>Bayes++.sln</strong> solution
and the active configuration <strong>uBLAS Debug</strong>. The compiler options
must be set so the additional <em>Boost</em> include files can be found.
In this case the <u>include path</u> must contain the base directory of Boost.
In this case the <strong>boost_1_29_0</strong> directory, In VC7 you should
do this by using <em>Tools/Options/Projects/VC++ Directories</em></p>
		
<h2>Licensing</h2>
		
<p>All Bayes++ source code files are copyright with the licence conditions
as given here. The copyright notice is that of the MIT license. This in no
way restricts any commercial use you may wish to make using our source code.
As long as you respect the copyright and license conditions, Michael Stevens
and the ACFR are happy to for you to use it in any way you wish.</p>
		
<p>Bayes++ the Bayesian Filtering Library</p>
		
<p>Copyright (c) 2002 Michael Stevens, Australian Centre for Field Robotics</p>
		
<p>Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:</p>
		
<p>The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.</p>
		
<p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.</p>
		
<h2>Portability</h2>
		
<p>Bayes++ only makes use of ISO standard C++. The source code uses moderately
advance C++ constructs but only restricted use of the C++ template system.
The Boost libraries used make extensive use of template techniques but also
include many workarounds for compiler deficiencies. Therefore with few alterations
Bayes++ should work with any modern C++ compiler supported by Boost</p>
		
<p>General testing is performed with GCC 3.x and 2.95.3 and also Visual C++
7 (.NET). It is also know to work with Visual C++6. However be aware that
this compiler can get very confused. Particular when complex templates the
order that headers are included can be important. &nbsp;Similarly VC7 often
requires the /Zm option to be used so it can compile complex headers.<br>
</p>
<p><strong>MTL</strong> works for these compilers, but the download of version
2.1.2-20 available is <strong>not</strong> up to date and contains some major
errors. Version 2.1.2-21 also seems to still have problems with newer compiler.
If you do not wish to apply many patches yourself <a href="#Download">download
my patched ZIP archive for the Bayes++</a>. For compilers other then Visual
C++ the mtl_config.h may have to be edited or recreated with autoconf.</p>
<h2>FAQ</h2>
		
<h4>Does Bayes++ do Kalman Filtering?</h4>
		
<p>Yes, there are many implementations in Bayes++. The Kalman Filter and the
Extended Kalman Filter are implemented by the <em>Covariance_filter</em>
Scheme.</p>
		
<h4>How fast is Bayes++?</h4>
		
<p>Pretty quick! Depends on the filter Scheme used. The <i>UD_filter</i>
is smallest and fastest Scheme. The best way to speed things up is to work
on optimised use of uBlas and to optimized uBlas itself for you compiler.</p>
		
<h4>Why should I use Bayes++? After all, writting a Kalman filter in Matlab
is not too hard.</h4>
		
<p>For a simple test this may be true. If you have ever tried to deal with
the wide variety of numerical failures and normalisations required to deal
with discontinues model you will realises that is more to implementing a
Kalman filter then a hand full of linear algebra equations!</p>
		
<p>Many DIY Kalman filter implementations fail as they do not maintain the
symmetry of matrices. If this is problem is corrected, they usually use numerically
inaccurate algorithms and also will silently continue to operate even when
the results no longer make sense. The matrices are ill conditioned! All these
hard problems have been solved for you by Bayes++.</p>
		
<p>However Bayes++ most powerful feature is <strong>not</strong> that it just
does things correctly? It provides a consistent methodology to apply multiple
Bayesian filtering techniques. Once you have codified the models that represent
a problem you can solve your problem with many difference Bayesian filtering
techniques. These may be simple Kalman filters such as the<em> Information_filter</em>
scheme, or even a particle filter such as the<em> SIR_filter</em> scheme.</p>
		
<h4>Is Bayes++ stable?</h4>
		
<p>Although many things have been added to Bayes++ over the last two years
they have only added to the variety of implementations. Bayes++'s interface
has now reached a very mature stage with little or no change required to
add new types of Bayesian filtering.&nbsp;Be aware however that the Matrix
support implementation (anything in namespace Bayesian_filter_matrix) may
change in the future.</p>
		
<p>The implementations of filtering Schemes included in the web release, have
all been tested with a standard range angle observation problem. I also use
the filtering Schemes for my own work, and others do so in the ACFR.&nbsp;</p>
		
<h4>Do I need to program in C++ to use Bayes++?</h4>
		
<p>Yes! Bayes++ was developed to provide the maximum functionality in C++.
A good C++ text book will help you understand how Bayes++ works. There is
no need to learn C programming first. Learning C is not a good introduction
to modern C++ programming techniques used in Bayes++. I would recommend Deitel
and Deitel, "C++: How to Program", Second Edition, Prentice Hall, ISBN 0-13-528910-6.
It is an excellent beginners book; and includes many useful tips and a thorough
understanding of the language.</p>
		
<h4>Where are the PDF?</h4>
<p>Bayes rule is usually defined in term of Probability Density Functions.
However PDFs never appear in Bayes++. They are always represented by their
statistics. &nbsp;This is for good reason, there is very little that can
be done algorithmically with a function. However the sufficient statistics,
given the assumptions of a filter, can be easily manipulated to implement
Bayes rule. Each filter class is derived from a base classes that represent
the statistics used. For example the <i>Kalman_filter</i> and <i>Sample_filter</i>
base classes.</p>
<h4>What Matrix library do you recommend?</h4>
		
<p>As of Boost version 1_29_0 it includes a public release of the uBlas library.
This an excellent linear algebra&nbsp; library. The interface and syntax
are easy to use. It provides a wide variety of matrix and vector containers
and a complete set of Basic Linear Algebra operations. The implementation
and structure can incorporate many future enhancements and efficiency improvements.&nbsp;The
more I use uBlas the more I like it! </p>
<p>Older releases of Bayes++ support both uBlas and <a
 href="http://www.osl.iu.edu/research/mtl/">MTL the Matrix Template Library</a>.
Future releases of MTL may also be of interest to Bayes++. However at present
nothing is being publicly releases so I will await the outcome.<br>
By simply changing the compiler include paths new matrix libraries can be
used when Bayes++ is built. This just requires a new version of <i>matSubSup.hpp</i>
to be found before the one supplied in Bayes++ itself.</p>
		
<p>Credit for uBlas goes to Joerg Walter and Mathias Koch. Many thanks!</p>
		
<h2><a name="whatsnew"></a>Whats new?</h2>
<h4>Covariance Intersect Scheme added</h4>
Finally the <b>CI</b> algorithm has been implemented as a Scheme in Bayes++.
CI is interesting as it provides a weaker but more robust fussion then traditional
covariance based method such as the Kalman filter. It estimates state and
an upper bound of what its covariance could be.
<h4>Importance Resampling infrastructure added</h4>
The flexibility of the <i>SIR_filter </i>has been greatly improved. A new
class<b></b><i>Importance_resampler</i> has been added. Whenever <i>SIR_filter
</i>need to resample it uses and Importance_resampler parameter. Therefore
by changing this parameter different resamplers can be used. <br>
Two implementation are provided. The <i>Standard_resampler</i> and the <i>Systematic_resampler</i>.
See the referenced publications for further dicussion of these methods.<br>
		
<h4>Interface changes and Matrix support</h4>
		
<p>This release only supplies a matrix abstraction layer for Boost uBlas.&nbsp;
The change reflects my wish to change the Bayes++ matrix syntax to more closely
reflect that of uBlas. There are a few simple changes to note:</p>
		
<ol>
  <li> nrows() and ncols() are now size1() and size2() </li>
  <li> set(X, 0.) should be replaced by X.clear() for any container type
  </li>
  <li> The operator* overloading is dropped. Use the explict X = prod(A,B)<br>
uBlas a has a wide variety of different product. Expression complexity can
be controlled by introducing a temporary. For example <i>prod&lt;type&gt;(A,B)</i>			can
be used to compute the product of A,B where the type is used to hold the
temporary result. </li>
  <li> Look out for the use of X.assign(EE). This is an optimised assignment
(instead of =) when the result of the expression EE is independant of X</li>
  <li>The type Subscript has been removed. All interfaces now use <b>size_t</b>
instead<br>
  </li>
		
</ol>
		
<h4>size_t may be different type from Subscript<br>
</h4>
		
<p><strong></strong>The effective type change from <strong>unsigned</strong>
to<strong>size_t</strong>. This will only have an effect on a 64bit or any
platform where these two types have a different size.</p>
		
<h4>Bug Fixed in old releases</h4>
		
<p>There is a nasty bug in all releases after 2002.3-1. This bug effects the
<i>UdUfactor_varient2</i> function that was added at this time. All UdUinverse
etc are incorrect for matrices larger then 2x2. ALL releases for download
have been corrected.<br>
<br>
</p>
<br>
<br>
<br>
<br>
<br>
</body>
</html>
