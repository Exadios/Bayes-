<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=iso-8859-15">
	<TITLE>Bayes++ Bayesian Filtering</TITLE>
	<META NAME="GENERATOR" CONTENT="OpenOffice.org 1.0.1  (Linux)">
	<META NAME="CREATED" CONTENT="20030727;11013700">
	<META NAME="CHANGEDBY" CONTENT="Michael Stevens">
	<META NAME="CHANGED" CONTENT="20030727;11160800">
</HEAD>
<BODY LANG="de-DE">
<H1 ALIGN=CENTER><U>Bayes++</U></H1>
<H1 ALIGN=CENTER><B>Open Source Bayesian Filtering Classes</B></H1>
<H2 ALIGN=CENTER>Michael Stevens</H2>
<P><BR>
<CENTER>
	<TABLE WIDTH=100% BORDER=5 CELLPADDING=0 CELLSPACING=4 BGCOLOR="#c0c0c0">
		<TR VALIGN=TOP>
			<TD WIDTH=368 HEIGHT=48>
				<H2><A HREF="./Bayesian Filtering Classes.htm">Bayesian Filtering</A></H2>
				<P>Overview of Bayesian filtering with the Filtering Classes 
			</TD>
			<TD WIDTH=330>
				<H2 ALIGN=RIGHT><A HREF="mailto:michael.stevens@epost.de">michael.stevens@epost.de</A></H2>
				<H2 ALIGN=RIGHT><A HREF="http://www.acfr.usyd.edu.au/">Australian
				Center for Field Robotics</A></H2>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=368>
				<H3><A HREF="ClassDocumentation/html/index.html">Documentation
				generated by Doxygen</A></H3>
				<BLOCKQUOTE><A HREF="ClassDocumentation/html/classBayesian__filter_1_1Bayes__filter__base.html">Filter
				hierarchy</A><BR><A HREF="ClassDocumentation/html/classBayesian__filter_1_1Predict__model__base.html">Prediction
				models</A> and <A HREF="ClassDocumentation/html/classBayesian__filter_1_1Observe__model__base.html">Observation
				models</A><BR><BR><A HREF="ClassDocumentation/html/functions.html">Class
				members</A> and <A HREF="ClassDocumentation/html/files.html">File
				list of Bayes++</A> 
				</BLOCKQUOTE>
			</TD>
			<TD WIDTH=330>
				<H3 ALIGN=RIGHT><A NAME="download"></A><A HREF="http://sourceforge.net/projects/bayesclasses/">Project
				Summary</A> and <A HREF="http://sourceforge.net/project/showfiles.php?group_id=54729">Download</A></H3>
				<P ALIGN=RIGHT><A NAME="CVS_Repository"></A><IMG SRC="http://sourceforge.net/sflogo.php?group_id=54729&amp;type=5" NAME="Grafik1" ALT="SourceForge Logo" ALIGN=BOTTOM WIDTH=75 HEIGHT=38 BORDER=0>
				<A HREF="http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/bayesclasses">CVS
				Repository</A> 
				</P>
				<P ALIGN=RIGHT>Bayes++ uses the <A HREF="http://www.boost.org/" TARGET="_top"><FONT SIZE=5>Boost</FONT>
				</A><BR>peer-reviewed portable C++ source libraries</TD>
		</TR>
	</TABLE>
</CENTER>
<P ALIGN=JUSTIFY>Bayesian Filtering is a probabilistic technique for
data fusion. The technique combines a concise mathematical
formulation of a system with observations of that system.
Probabilities are used to represent the state of a system, likelihood
functions to represent their relationships. In this form Bayesian
inference can be applied and further related probabilities deduced.
See <A HREF="http://www.wikipedia.org/">Wikipedia</A> for information
on <A HREF="http://www.wikipedia.org/wiki/Probability_theory">Probability
theory</A>, <A HREF="http://www.wikipedia.org/wiki/Bayes'_theorem">Bayes
theorem</A>, <A HREF="http://www.wikipedia.org/wiki/Bayesian_inference">Bayesian
Inference</A>.</P>
<P ALIGN=JUSTIFY>For <U>discrete</U> systems the Bayesian formulation
results in a naturally iterative data fusion solution. For <U>dynamic</U>
systems there is a class of solutions, discreate <U>filters</U>, that
combine observed inputs to the system with the dynamic model . A
filter that iteratively incorporates new information is an <U>estimator</U>.
For linear dynamic systems, discrete solutions such as the Kalman
filter apply.</P>
<P ALIGN=JUSTIFY>Bayes++ is an open source library of C++ classes.
These classes represent and implement a wide variety of numerical
algorithms for Bayesian Filtering of discrete systems. The classes
provide tested and consistent numerical methods and the class
hierarchy explicitly represents the variety of filtering algorithms
and system model types.</P>
<H2>Simple Example</H2>
<P>This is very simple example; for those who have never used the
Bayesian Filtering Classes before. If you wish, <A HREF="Simple/simpleExample.cpp">View
the Source</A> online</P>
<P>The example shows how two classes are created. The first is the
prediction model, the second the observation model. In this example
they represent a simple linear problem with only one state variable
and constant model noises. A filter fuses the results of prediction
and observation.</P>
<P>Compiling the Examples</P>
<P>First <A HREF="#download">download</A> and extract <B>Bayes++</B>
and also the <B>Boost</B> library. <B>Boost</B> is used to provide
compiler independence, and a common build system. Two Boost header
libraries are used: <B>uBlas</B> for linear algebra, and <B>random</B>
for the PV and QuadCalib examples. The Boost headers can be placed
anywhere relative to Bayes++, but it is easy if you follow this
structure:</P>
<DL>
	<DL>
		<DT><EM>...sourceDirectory</EM> 
		</DT><DL>
			<DT>
			Bayes++ 
			</DT><DL>
				<DT>
				BayesFilter 
				</DT><DT>
				PV 
				</DT><DT>
				QuadCalib 
				</DT><DT>
				Simple 
				</DT><DT>
				Test</DT></DL>
			<DT>
			boost_1_30_0 
			</DT><DL>
				<DT>
				boost 
				</DT><DT>
				<I>etc</I></DT></DL>
		</DL>
	</DL>
</DL>
<P>
Using the Boost Build system is the best way to compile the examples.
This uses the <B>bjam</B> (Boost jam) program to compute dependencies
and invoke the compiler.&nbsp; The documentation in your downloaded
copy of Boost explains how to obtain bjam and the sources to compile
it yourself. For everything to work <B>bjam</B> must be placed in the
path. <BR>To build Bayes++ and the examples simply execute: (Bayes++
should be the current directory)</P>
<PRE>        bjam -s&quot;BOOST_ROOT=../boost_1_30_0&quot;</PRE><P>
If there is more then one toolset (compiler etc) available you may
want to tell bjam which to use. For example to use Visual C++ 7
execute:</P>
<PRE>        bjam -sTOOLS=&quot;vc7&quot; -s&quot;BOOST_ROOT=../boost_1_30_0&quot;</PRE><P>
It is possible to drop the BOOST_ROOT variable by either creating a
<B>build_build.jam</B> file in <I>sourceDirectory</I> (or above) or
by setting it as an enviroment variable. A simple Makefile also
exists to encapsulate the bjam build commands.</P>
<H4>Location of compiled examples and libraries</H4>
<P>The executable for each example will be placed inside a directory
heirarchy named <B>target</B>. Static libraries for debug and release
builds of the BayesFilter library are placed in <B>target/lib</B>.
The <B>target </B>directory and its subdirectories are created
automatically.</P>
<H4>Visual C++ solution</H4>
<P>For Visual C++ 7 you can also use the <B>Bayes++.sln</B> solution
and the active configuration <B>uBLAS Debug</B>. The compiler options
must be set so the <B>Boost</B> include files can be found. That is,
the <U>include path</U> must contain the base directory of Boost. In
this case the <B>boost_1_30_0</B> directory. In VC7 you should do
this by choosing the <I>Tools/Options/Projects/VC++ Directories</I>
option.</P>
<H2>Licensing</H2>
<P>All Bayes++ source code files are copyright with the licence
conditions as given here. The copyright notice is that of the MIT
license. This in no way restricts any commercial use you may wish to
make using our source code. As long as you respect the copyright and
license conditions, Michael Stevens and the Australian Centre for
Field Robotics are happy to for you to use it in any way you wish.</P>
<P>Bayes++ the Bayesian Filtering Library</P>
<P>Copyright (c) 2002 Michael Stevens and Australian Centre for Field
Robotics</P>
<P>Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation files
(the &quot;Software&quot;), to deal in the Software without
restriction, including without limitation the rights to use, copy,
modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished
to do so, subject to the following conditions:</P>
<P>The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.</P>
<P>THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF
ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.</P>
<H2>SLAM : Simultaneous Localization and Mapping</H2>
<P>SLAM is one of the most interesting problems in Bayesian
filtering. It's struture implies that it cannot be correctly solved
without using stochastic approach. This is due to mapped states being
dependant on other mapped states and the localization state. This
dependance also make the problem complex, therefore a simple approach
such as representing all correlations is not tractable for large
numbers of states.</P>
<P>Bayes++ has been used to implement various simple and some more
advanaced SLAM solutions. In particular a full implementation of
FastSLAM has been implemented. This technique is described in the
paper &quot;FastSLAM : Factored Solution to the Simultaneous
Localization and Mapping Problem&quot;,&nbsp; M. Montemerlo, S. Thrun
S, D. Koller, B.Wegbreit, Proceedings of the AAAI National Conference
on Artificial Intelligence&nbsp; 2002.</P>
<P>The Bayes++ implemention of FastSLAM and a very simple Kalman
(full correlation) SLAM implementation is available as part of the
most recent <A HREF="Bayes++.htm#download">download</A>.</P>
<H2>Scilab, Matlab, MuPAD</H2>
<P>These mathematical tools are particularly useful for visualising
filtering results. However they are all rather slow, and it is very
easy to produce very poorly implemented filters in their programming
languages. Fortuneately all these tools provide mechanisms for
extension with external programs. Example interface code is provided
in the <A HREF="#CVS_Repository">Bayes++ CVS repository</A> for
Matlab and MuPAD. An interface to Scilab is not yet available.</P>
<H2>Portability</H2>
<P>Bayes++ only makes use of ISO standard C++. The source code uses
moderately advance C++ constructs. It only makes restricted use of
the C++ template system directly. However the Boost libraries used
(in particular uBLAS) make extensive use of template techniques.
Boost also includes many workarounds for compiler deficiencies.
Therefore with few alterations Bayes++ should work with any modern
C++ compiler supported by Boost.</P>
<P>Bayes++ is compatible with: <B>GCC 3.2</B>, <B>GCC 2.95.3</B>,
<B>VisualC++ 7 (.NET)</B> and <B>IntelC++ 7.1</B><BR>Releases are
validated with these compilers using a set of regression tests. Later
versions of GCC 3.x.y should also run Bayes++ with ease.</P>
<P>Previously Bayes++ was compatible with Visual C++6, but new
releases have not been tested. Be aware that VC6 can get very
confused! Particular when complex templates compiled. The order that
headers are included can be important. &nbsp;Similarly VC7 often
requires the /Zm option to be used so it can compile complex headers.</P>
<H2>FAQ</H2>
<H4>Does Bayes++ do Kalman Filtering?</H4>
<P>Yes, there are many Kalman filter implementations in Bayes++. In
Bayes++, the Kalman Filter and the Extended Kalman Filter (EKF) are
implemented by the <I>Covariance_filter</I> Scheme.</P>
<H4>How fast is Bayes++?</H4>
<P>Pretty quick! Depends on the filter Scheme used. The <I>UD_filter</I>
is smallest and fastest Scheme. The best way to speed things up is to
work on optimised use of uBlas and to optimized uBlas itself for you
compiler.</P>
<H4>What is a 'Scheme'?</H4>
<P>A 'Scheme' is the term used in Bayes++ to define a particular
numerical implemention of a filter. Each Scheme is based on one of a
few statistical representations of state. Different schemes work on
these statistics using different numerical techniques. The aim of
Bayes++ is to provides common interfaces to Schemes so you can pick
an choose which to use.</P>
<H4>Why should I use Bayes++? After all, writting a Kalman filter in
Matlab is not too hard.</H4>
<P>For a simple test this may be true. If you have ever tried to deal
with the wide variety of numerical failures and normalisations
required to deal with discontinues model you will realises that there
is more to implementing a Kalman filter then a hand full of linear
algebra equations!</P>
<P>Many DIY Kalman filter implementations fail as they do not
maintain the symmetry of matrices. If this is problem is corrected,
they usually use numerically inaccurate algorithms and also will
silently continue to operate even when the results no longer make
sense. The matrices are ill conditioned! All these hard problems have
been solved for you by Bayes++.</P>
<P>However Bayes++ most powerful feature is <B>not</B> that it just
does things correctly! It provides a consistent methodology to apply
multiple Bayesian filtering techniques. Once you have codified the
models that represent a problem you can solve your problem with many
difference Bayesian filtering techniques. These may be simple linear
filters such as the <I>Information_filter</I> scheme, or even a
particle filter such as the <I>SIR_filter</I> scheme.</P>
<H4>Is Bayes++ stable?</H4>
<P>Although many things have been added to Bayes++ over the last two
years they have only added to the variety of implementations.
Bayes++'s interface has now reached a very mature stage with little
or no change required to add new Schemes.&nbsp;Be aware however that
the Matrix support implementation (anything in namespace
Bayesian_filter_matrix) may change in the future.</P>
<P>The implementations of filtering Schemes included in the web
release, have all been tested with a standard range angle observation
problem. I also use the filtering Schemes for my own work, and so do
others at the <A HREF="http://www.acfr.usyd.edu.au/">Australian
Center for Field Robotics</A> and all over the world.</P>
<H4>Do I need to program in C++ to use Bayes++?</H4>
<P>Yes! Bayes++ was developed to provide the maximum functionality in
C++. A good C++ text book will help you understand how Bayes++ works.
There is no need to learn C programming first. Learning C is not a
good introduction to modern C++ programming techniques used in
Bayes++. I would recommend Deitel and Deitel, &quot;C++: How to
Program&quot;, Second Edition, Prentice Hall, ISBN 0-13-528910-6. It
is an excellent beginners book; and includes many useful tips and a
thorough understanding of the language.</P>
<H4>Where are the PDFs?</H4>
<P>Bayes rule is usually defined in term of Probability Density
Functions. However PDFs never appear in Bayes++. They are always
represented by their statistics. &nbsp;This is for good reason, there
is very little that can be done algorithmically with such a function.
However the sufficient statistics, given the assumptions of a filter,
can be easily manipulated to implement Bayes rule. This is essential
what Kalman developed for linear systems. 
</P>
<P>Each filter scheme is derived from one or more virtual base
classes that represent the statistics used. For example the
<I>Kalman_state_filter</I> and <I>Sample_filter</I> base classes.</P>
<H4>What Matrix library do you recommend?</H4>
<P>As of version 1_29_0 <A HREF="http://www.boost.org/"><B>Boost</B></A>
includes a public release of the <A HREF="http://www.boost.org/libs/numeric/ublas/doc/index.htm"><B>uBLAS</B></A>
library. This an excellent linear algebra&nbsp; library. The
interface and syntax are easy to use. It provides a wide variety of
matrix and vector containers and a complete set of Basic Linear
Algebra operations. The implementation and structure can incorporate
many future enhancements and efficiency improvements. The more I use
uBLAS the more I like it! See also my note on <A HREF="http://www.crystalclearsoftware.com/cgi-bin/boost_wiki/wiki.pl?Effective_UBLAS">Effective
uBLAS</A> on the Boost Wiki.</P>
<P>Credit for uBLAS goes to Joerg Walter and Mathias Koch. Many
thanks!</P>
<P>Older releases of Bayes++ support both uBlas and <A HREF="http://www.osl.iu.edu/research/mtl/">MTL
the Matrix Template Library</A>. Future releases of MTL may also be
of interest to Bayes++. However at present nothing is being publicly
releases so I will await the outcome.</P>
<P>In principle it is possible to use a different matrix library when
Bayes++ is built. This just requires a new version of <I>matSubSup.hpp</I>
to be found before the one supplied in Bayes++ itself. However
Bayes++ makes extensive use of uBLAS syntax, so a change is a
significant task.</P>
<H2><A NAME="whatsnew"></A>What's new in Bayes++ 2003-7?</H2>
<H3>Compiler support</H3>
<P>The list of compiler for which Bayes++ is built and tested has
been extended. It is validated ofr GCC 3.2, GCC 2.95.3, VisualC++
7.0, and IntelC++ 7.1</P>
<H3>New Boost Support</H3>
<P>Jens Mauer has been working hard on getting <B>boost::random</B>
accepted as part of the future C++ standard library. To this end
there have been substantial changes to its interface. These have now
be commited to Boost. The Bayes++ examples make use of boost::random.
So things migrate smoothly I have added a new &quot;test/random.hpp&quot;
header which hides the interface changes.</P>
<P>The very excellent <B>Boost Build system version 2 </B>has
advanced a great deal recently. Bayes++ is normal built with standard
Boost Build system. You can select the version 2 build system by
simply using &quot;bjam --v2&quot;. Bayes++ has all the necessary
&quot;Jamfiles.v2&quot; to use the new system.</P>
<H3>Scheme extensions</H3>
<P>The UD_scheme observe functions have had their numerical
capabilities extended to include a PSD state covariance. It is now
possible to work with singular covariance matrices.</P>
<P>The Unscented_scheme has additional function init_XX() and
update_XX() to allow access to an Unscented state representation</P>
<H3>Numeric fixes</H3>
<P>An error in SIR_kalman_schemes covariance calculation has been
fixed. This error also effected the Fast_kalman_SLAM implementation.
The error was significant for small small sizes.</P>
<H2>What's new in Bayes++ 2003-5?</H2>
<H3>'noalias' assignment</H3>
<P>For efficiency it is important to avoid creating temporary matrix
and vector copies. Unless told otherwise it is not possible for <B>uBLAS
</B>to determine if the same matrix or vector variable is specified
on both the left and right hand side of an assignment operation. If
such variable does appear it is said to be an <I>alias</I>. Because
assignment involves more then one element, the presence of an alias
requires that an assignment first compute a temporary result before
the aliased variable is modified.</P>
<P><B>uBLAS</B>'s default behaviour is to create such a temporary. If
the assignment is know to be free of an alias this should be avoided.
Previously such an optimised assignment was specified with the
<B>.assign()</B> member functions. To improve the readability of code
I have added a new syntax for assignment. Where no aliases of
variable assigned to (lvalue) appears in the expression on the right
hand side of the assignmment use:</P>
<PRE> noalias(lvalue) = expression;</PRE><P>
This new syntax is experimental but will probably be part of a future
<B>uBLAS</B> release. At present the implementation introduces a
small overhead on the supported compilers. This includes GCC 3.2.</P>
<H2>What's new in Bayes++ 2003-3?</H2>
<H3>Filters are named <I>_filter</I>, Schemes are named <I>_scheme</I></H3>
<P>Abstract filters and numeric schemes previously all had names
ending in <I>_filter</I>. To make things simpler the naming has been
changed to make a clear seperation in what is a two level hierarchy.</P>
<P>Filters lie at the base of the hierarchy. Schemes are always
derived from one of more filters. Filters represent abstract
concepts, such as the statistics of state representation and model
interface. Schemes are concreate implementations of a filter with all
the numeric details and interfaces completed.</P>
<P>As part of this change the statistics of state representation have
been made <B>virtual base classes</B>. This change is designed to
allow multiple schemes combined together (using multiple inheritance)
and share their reperesntation. The change adds a little more work if
you choose to derive from a scheme class. The constructors for the
derived class must call the constructors for the virtual base classes
directly.</P>
<H3>Covariance Intersect Scheme added</H3>
<P>Finally the <B>CI</B> algorithm has been implemented as a Scheme
in Bayes++. CI is interesting as it provides a weaker but more robust
fussion then traditional covariance based method such as the Kalman
filter. It estimates state and an upper bound of what its covariance
could be.<BR><BR>Actually only the matrix algebra associated with CI
has is included. The CI_filter scheme provides a virtual function
where the user must define the actual optimisation algorithm to be
used.</P>
<H3>Importance Resampling infrastructure added</H3>
<P>The flexibility of the <I>SIR_filter </I>has been greatly
improved. A new class <I>Importance_resampler</I> has been added.
Whenever <I>SIR_filter </I>need to resample it uses and
Importance_resampler parameter. Therefore by changing this parameter
different resamplers can be used. 
</P>
<P>Two implementation are provided. The <I>Standard_resampler</I> and
the <I>Systematic_resampler</I>. See the referenced publications for
further dicussion of these methods.</P>
<H3>Gappy Matrices</H3>
<P>The matrix interface has been further improved. These improvment
require uBLAS from boost_1_30_0. With this version there is now
experimantal support for using uBLAS <B>gappy</B> matrices and
vectors (sparse, compressed, coordinate).</P>
<P>The experimental support makes all of Bayes++ use a selected uBLAS
storage type. Check <B>matSupSub.hpp </B>for macro's required to
enable this. The algorithms used is Bayes++ are being upgraded to
perform better with sparse types.</P>
<P>The mult_SPD products are no longer supported. They are replaced
with the prod_SPD interface.</P>
<H3>Matrix Interface changes included from 2002.10</H3>
<P>This release only supplies a matrix abstraction layer for Boost
uBlas. The change reflects my wish to change the Bayes++ matrix
syntax to more closely reflect that of uBlas. There are a few simple
changes to note:</P>
<OL>
	<LI>nrows() and ncols() are now size1() and size2() 
	<LI>set(X, 0.) should be replaced by X.clear() for any container
	type 
	<LI>The operator* overloading is dropped. Use the explict X =
	prod(A,B)<BR>uBlas a has a wide variety of different product.
	Expression complexity can be controlled by introducing a temporary.
	For example <I>prod&lt;type&gt;(A,B)</I> can be used to compute the
	product of A,B where the type is used to hold the temporary result. 
	<LI>Look out for the use of X.assign(EE). This is an optimised
	assignment (instead of =) when the result of the expression EE is
	independant of X 
	<LI><P>The type Subscript has been removed. All interfaces now use
	<B>size_t</B> instead</P>
</OL>
<H3>size_t may be different type from Subscript</H3>
<P>The effective type change from <B>unsigned</B> to <B>size_t</B>.
This will only have an effect on a 64bit or any platform where these
two types have a different size.</P>
</BODY>
</HTML>