<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
  <title>Bayes++ Bayesiean Filtering Classes</title>
                    
  <link media="all" href="http://www.acfr.usyd.edu.au/style.css"
 type="text/css" rel="Stylesheet">
</head>
  <body>
       
<h1 align="center"><u>Bayes++ Bayesian Filter Classes</u></h1>
    		    
<div>			    
<table height="203" cellpadding="0" align="center" border="5"
 cellspacing="4" bgcolor="#c0c0c0">
      <tbody>
        <tr>
          <td valign="top" width="368" height="48">							              
                                                         
      <h2><a href="Bayesian%20Filtering%20Classes.htm">Bayesian Filtering</a></h2>
          Overview of Bayesian filtering with the Filtering Classes </td>
          <td valign="top" width="330" height="48">							              
                                                         
      <h2 align="right"><a href="mailto:michael@acfr.usyd.edu.au">michael@acfr.usyd.edu.au</a></h2>
                                                           
      <h2 align="right"><a href="http://www.acfr.usyd.edu.au">Australian Center
for Field Robotics</a></h2>
          </td>
        </tr>
        <tr>
          <td valign="top" width="368">							                          
                                                          
      <p>Doxumentation generated by Doxygen.<br>
          <a href="ClassDocumentation/html/index.html"> View the structure
 of  Bayes++</a></p>
                                                           
      <blockquote dir="ltr" style="margin-right: 0px;">	<a
 href="ClassDocumentation/html/hierarchy.html" target="_top">Class hierarchy
  of Bayes++</a><br>
            <a href="ClassDocumentation/html/functions.html"
 target="_top">Class  member of Bayes++</a><br>
            <a href="ClassDocumentation/html/files.html" target="_top">File 
 List of Bayes++</a>     </blockquote>
          </td>
          <td valign="top" width="330">							                          
                                                                        
                                                     
      <h3 align="right"><a name="download"></a><a
 href="http://sourceforge.net/projects/bayesclasses/">Project Summary</a>
  and <a
 href="http://sourceforge.net/project/showfiles.php?group_id=54729">Download</a></h3>
                                                           
      <p align="right"><img alt="SourceForge Logo"
 src="http://sourceforge.net/sflogo.php?group_id=54729&amp;amp;type=5"
 border="0">
         </p>
                                                           
      <p align="right">Bayes++ uses the <big><a
 href="http://www.boost.org" target="_top">Boost</a></big><br>
    peer-reviewed portable C++ source libraries</p>
          </td>
        </tr>
    				                                                                
   
  </tbody>    
</table>
    </div>
    		  		    
<p>Bayesian Filtering is a probabilistic technique for data fusion. The technique
  combines a concise mathematical formulation of a system with observations
  of that system. Probabilities are used to represent the state of a system,
  likelihood functions to represent their relationships. In this form Bayesian 
 inference can be applied and further related probabilities deduced. See <a
 href="http://www.wikipedia.org/">Wikipedia</a> for information on <a
 href="http://www.wikipedia.org/wiki/Probability_theory">Probability theory</a>, 
 <a href="http://www.wikipedia.org/wiki/Bayes%27_theorem">Bayes theorem</a>, 
 <a href="http://www.wikipedia.org/wiki/Bayesian_inference">Bayesian Inference</a>.</p>
     
<p>For <u>discrete</u> systems the Bayesian formulation results in a naturally
  iterative data fusion solution. For <u>dynamic</u> systems there is a class
  of solutions, discreate <u>filters</u>, that combine observed inputs to
the  system with the dynamic model . A filter that iteratively incorporates
new  information is an <u>estimator</u>. For linear dynamic systems, discrete 
 solutions such as the Kalman filter apply.</p>
       
<p>Bayes++ is a library of C++ classes. These classes represent and implement
  a wide variety of numerical algorithms for Bayesian Filtering of discrete
  systems. The classes provide tested and consistent numerical methods and
 the class hierarchy explicitly represents the variety of filtering algorithms
  and system model types.</p>
    		    
<h2>Simple Example</h2>
    		    
<p>This is very simple example; for those who have never used the Bayesian
  Filtering Classes before. If you wish, <a href="simpleExample.cpp">View
the  Source</a> online</p>
    		    
<p>The example shows how two classes are created. The first is the prediction
  model, the second the observation model. In this example they represent
a  simple linear problem with only one state variable and constant model
noises.  A filter fuses the results of prediction and observation.</p>
    				    
<h2>Compiling the Examples</h2>
    		    
<p>First <a href="#download">download</a> and extract <b>Bayes++</b> and also
the <b>Boost</b> library. <b>Boost</b> is used to provide compiler independence,
  and a common build system. Two Boost header libraries are used: <b>uBlas</b>
  for linear algebra, and <b>random</b> for the PV and QuadCalib examples.
 The Boost headers can be placed anywhere relative to Bayes++, but it is
easy  if you follow this structure:</p>
    		    
<dl>
  <dl>
    <dt><em>...sourceDirectory</em> </dt>
    <dl>
      <dt>Bayes++            </dt>
      <dl>
        <dt>BayesFilter</dt>
        <dt>PV</dt>
        <dt>QuadCalib</dt>
        <dt>Simple</dt>
      </dl>
      <dt>boost_1_30_0&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;<i>The first version
 of Boost to include uBlas was boost_1_29_0</i></dt>
      <dl>
        <dt>boost</dt>
      </dl>
    </dl>
  </dl>
</dl>
    		    
<p>Using the Boost Build system is the best way to compile the examples. This
uses the <b>bjam</b> (Boost jam) program to compute dependencies and invoke
the compiler. To make things simpler a simple Makefile exists that will set
everything up and then begin the build process using Boost Build. &nbsp;For
this to work <b>bjam</b> must be placed in the path. The documentation in
your downloaded copy of Boost explains how to obtain bjam and the sources
  to compile it yourself.<br>
    Therefore to build all the examples simply use:<br>
    </p>
       
<blockquote><i>make</i> &nbsp;for GCC tools<br>
    <i>nmake TOOLS='vc7'</i> &nbsp;for Visual C++ 7<br>
  </blockquote>
  The executable for each examples will be placed inside a directory <i>targert</i>
 that will be created.<br>
       
<p>For Visual C++ 7 you can also use the <strong>Bayes++.sln</strong> solution
  and the active configuration <strong>uBLAS Debug</strong>. The compiler
options  must be set so the additional <em>Boost</em> include files can be
found. In this case the <u>include path</u> must contain the base directory
of Boost. In this case the <strong>boost_1_29_0</strong> directory, In VC7
you should do this by using <em>Tools/Options/Projects/VC++ Directories</em></p>
    		    
<h2>Licensing</h2>
    		    
<p>All Bayes++ source code files are copyright with the licence conditions
  as given here. The copyright notice is that of the MIT license. This in
no  way restricts any commercial use you may wish to make using our source
code.  As long as you respect the copyright and license conditions, Michael
Stevens  and the ACFR are happy to for you to use it in any way you wish.</p>
    		    
<p>Bayes++ the Bayesian Filtering Library</p>
    		    
<p>Copyright (c) 2002 Michael Stevens, Australian Centre for Field Robotics</p>
    		    
<p>Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
  to deal in the Software without restriction, including without limitation
  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 and/or sell copies of the Software, and to permit persons to whom the Software 
 is furnished to do so, subject to the following conditions:</p>
    		    
<p>The above copyright notice and this permission notice shall be included
  in all copies or substantial portions of the Software.</p>
    		    
<p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL
 THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM,  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN  THE SOFTWARE.</p>
    		    
<h2>Portability</h2>
    		    
<p>Bayes++ only makes use of ISO standard C++. The source code uses moderately
  advance C++ constructs but only restricted use of the C++ template system.
  The Boost libraries used make extensive use of template techniques but
also   include many workarounds for compiler deficiencies. Therefore with
few alterations   Bayes++ should work with any modern C++ compiler supported
by Boost</p>
    		    
<p>General testing is performed with GCC 3.x and 2.95.3. It is generally
compatible Visual C++   7 (.NET) and Visual C++6, but new releases have not
tested. Be aware that VC6 can get very confused. Particular when complex
templates the   order that headers are included can be important. &nbsp;Similarly
VC7 often   requires the /Zm option to be used so it can compile complex
headers.<br>
    </p>
       
<p><strong>MTL</strong> works for these compilers, but the download of version
  2.1.2-20 available is <strong>not</strong> up to date and contains some
major  errors. Version 2.1.2-21 also seems to still have problems with newer
compiler.  If you do not wish to apply many patches yourself <a
 href="#Download">download  my patched ZIP archive for the Bayes++</a>. For
compilers other then Visual  C++ the mtl_config.h may have to be edited or
recreated with autoconf.</p>
       
<h2>FAQ</h2>
    		    
<h4>Does Bayes++ do Kalman Filtering?</h4>
    		    
<p>Yes, there are many implementations in Bayes++. The Kalman Filter and the
Extended Kalman Filter are implemented by the <em>Covariance_filter</em>
  Scheme.</p>
    		    
<h4>How fast is Bayes++?</h4>
    		    
<p>Pretty quick! Depends on the filter Scheme used. The <i>UD_filter</i>
is smallest and fastest Scheme. The best way to speed things up is to work
on optimised use of uBlas and to optimized uBlas itself for you compiler.</p>
    		    
<h4>Why should I use Bayes++? After all, writting a Kalman filter in Matlab
  is not too hard.</h4>
    		    
<p>For a simple test this may be true. If you have ever tried to deal with
  the wide variety of numerical failures and normalisations required to deal
  with discontinues model you will realises that is more to implementing
a  Kalman filter then a hand full of linear algebra equations!</p>
    		    
<p>Many DIY Kalman filter implementations fail as they do not maintain the
  symmetry of matrices. If this is problem is corrected, they usually use
numerically  inaccurate algorithms and also will silently continue to operate
even when  the results no longer make sense. The matrices are ill conditioned!
All these  hard problems have been solved for you by Bayes++.</p>
    		    
<p>However Bayes++ most powerful feature is <strong>not</strong> that it just
does things correctly? It provides a consistent methodology to apply multiple
Bayesian filtering techniques. Once you have codified the models that represent
a problem you can solve your problem with many difference Bayesian filtering
techniques. These may be simple Kalman filters such as the<em> Information_filter</em>
scheme, or even a particle filter such as the<em> SIR_filter</em> scheme.</p>
    		    
<h4>Is Bayes++ stable?</h4>
    		    
<p>Although many things have been added to Bayes++ over the last two years
  they have only added to the variety of implementations. Bayes++'s interface
  has now reached a very mature stage with little or no change required to
 add new types of Bayesian filtering.&nbsp;Be aware however that the Matrix
 support implementation (anything in namespace Bayesian_filter_matrix) may
 change in the future.</p>
    		    
<p>The implementations of filtering Schemes included in the web release, have
all been tested with a standard range angle observation problem. I also use
the filtering Schemes for my own work, and others do so in the ACFR.&nbsp;</p>
    		    
<h4>Do I need to program in C++ to use Bayes++?</h4>
    		    
<p>Yes! Bayes++ was developed to provide the maximum functionality in C++.
  A good C++ text book will help you understand how Bayes++ works. There
is   no need to learn C programming first. Learning C is not a good introduction
  to modern C++ programming techniques used in Bayes++. I would recommend
Deitel  and Deitel, "C++: How to Program", Second Edition, Prentice Hall,
ISBN 0-13-528910-6.  It is an excellent beginners book; and includes many
useful tips and a thorough  understanding of the language.</p>
      
<h4>Where are the PDF?</h4>
     
<p>Bayes rule is usually defined in term of Probability Density Functions.
  However PDFs never appear in Bayes++. They are always represented by their
  statistics. &nbsp;This is for good reason, there is very little that can
 be done algorithmically with a function. However the sufficient statistics,
 given the assumptions of a filter, can be easily manipulated to implement
 Bayes rule. Each filter class is derived from a base classes that represent
 the statistics used. For example the <i>Kalman_filter</i> and <i>Sample_filter</i>
  base classes.</p>
       
<h4>What Matrix library do you recommend?</h4>
     
<p>As of Boost version 1_29_0 it includes a public release of the uBlas library.
  This an excellent linear algebra&nbsp; library. The interface and syntax
 are easy to use. It provides a wide variety of matrix and vector containers
 and a complete set of Basic Linear Algebra operations. The implementation
 and structure can incorporate many future enhancements and efficiency improvements.&nbsp;The
  more I use uBlas the more I like it!</p>
       
<p>Older releases of Bayes++ support both uBlas and <a
 href="http://www.osl.iu.edu/research/mtl/">MTL the Matrix Template Library</a>.
  Future releases of MTL may also be of interest to Bayes++. However at present
  nothing is being publicly releases so I will await the outcome.<br>
    By simply changing the compiler include paths new matrix libraries can
 be  used when Bayes++ is built. This just requires a new version of <i>matSubSup.hpp</i>
  to be found before the one supplied in Bayes++ itself.</p>
     
<p>Credit for uBlas goes to Joerg Walter and Mathias Koch. Many thanks!</p>
      
<h2><a name="whatsnew"></a>Whats new?</h2>
       
<h4>Covariance Intersect Scheme added</h4>
    Finally the <b>CI</b> algorithm has been implemented as a Scheme in Bayes++.
  CI is interesting as it provides a weaker but more robust fussion then
traditional   covariance based method such as the Kalman filter. It estimates
state and   an upper bound of what its covariance could be.    
<h4>Importance Resampling infrastructure added</h4>
    The flexibility of the <i>SIR_filter </i>has been greatly improved. A 
new  class<i>Importance_resampler</i> has been added. Whenever <i>SIR_filter
  </i>need to resample it uses and Importance_resampler parameter. Therefore
  by changing this parameter different resamplers can be used. <br>
    Two implementation are provided. The <i>Standard_resampler</i> and the
 <i>Systematic_resampler</i>.  See the referenced publications for further
 dicussion of these methods.<br>
      
<h4>Interface changes and Matrix support</h4>
     
<p>This release only supplies a matrix abstraction layer for Boost uBlas.&nbsp;
  The change reflects my wish to change the Bayes++ matrix syntax to more
closely  reflect that of uBlas. There are a few simple changes to note:</p>
     
<ol>
      <li> nrows() and ncols() are now size1() and size2() </li>
      <li> set(X, 0.) should be replaced by X.clear() for any container type
    </li>
      <li> The operator* overloading is dropped. Use the explict X = prod(A,B)<br>
    uBlas a has a wide variety of different product. Expression complexity
 can  be controlled by introducing a temporary. For example <i>prod&lt;type&gt;(A,B)</i> 
 can be used to compute the product of A,B where the type is used to hold
 the temporary result.</li>
      <li> Look out for the use of X.assign(EE). This is an optimised assignment
  (instead of =) when the result of the expression EE is independant of X</li>
      <li>The type Subscript has been removed. All interfaces now use <b>size_t</b>
  instead<br>
      </li>
     
</ol>
      
<h4>size_t may be different type from Subscript</h4>
     
<p><strong></strong>The effective type change from <strong>unsigned</strong>
  to<strong>size_t</strong>. This will only have an effect on a 64bit or
any   platform where these two types have a different size.</p>
      
<h4>Bug Fixed in old releases</h4>
     
<p>There is a nasty bug in all releases after 2002.3-1. This bug effects the
<i>UdUfactor_varient2</i> function that was added at this time. All UdUinverse
  etc are incorrect for matrices larger then 2x2. ALL releases for download
  have been corrected.<br>
   </p>
  <br>
   <br>
</body>
</html>
