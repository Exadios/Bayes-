<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>
  <meta http-equiv="CONTENT-TYPE" content="text/html; charset=utf-8">
  <title>Bayes++ FAQ</title>
  <link rel="stylesheet" href="Deployment/paper.css" type="text/css">
</head>
<body dir="ltr" lang="en-US">
<h1 align="center"><u>Bayes++ FAQ</u></h1>

<h1 align="center"><b>Open Source Bayesian Filtering Classes</b></h1>

<h2 align="center">Michael Stevens</h2>

<h4>Does Bayes++ do Kalman Filtering?</h4>
<p>Yes, there are many Kalman filter implementations in Bayes++. In
Bayes++, the Kalman Filter and the Extended Kalman Filter (EKF) are
implemented by the <i>Covariance_filter</i> Scheme.</p>

<h4>How fast is Bayes++?</h4>
<p>Pretty quick! Depends on the filter Scheme used. The <i>UD_filter</i>
is smallest and fastest Scheme. The best way to speed things up is to
work on optimized use of uBLAS and to optimized uBLAS itself for you
compiler.</p>

<h4><a name="What_is_a_Scheme"></a>What is a 'Scheme'?</h4>
<p>A 'Scheme' is the term used in Bayes++ to define a particular
numerical implementation of a filter. Each Scheme is based on one of
a few statistical representations of state. Different schemes work on
these statistics using different numerical techniques. The aim of
Bayes++ is to provides common interfaces to Schemes so you can pick
an choose which to use.</p>

<h4>Why should I use Bayes++? After all, writing a Kalman filter in
Matlab is not too hard.</h4>
<p>For a simple test this may be true. If you have ever tried to deal
with the wide variety of numerical failures and normalizations
required to deal with discontinues model, you will realize that there
is more to implementing a Kalman filter then a hand full of linear
algebra equations!</p>
<p>Many DIY Kalman filter implementations fail as they do not
maintain the symmetry of matrices. If this is problem is corrected,
they usually use numerically inaccurate algorithms and also will
silently continue to operate even when the results no longer make
sense. The matrices are ill conditioned! All these hard problems have
been solved for you by Bayes++.</p>
<p>However Bayes++ most powerful feature is <b>not</b> that it just
does things correctly! It provides a consistent methodology to apply
multiple Bayesian filtering techniques. Once you have codified the
models that represent a problem you can solve your problem with many
difference Bayesian filtering techniques. These may be simple linear
filters such as the <i>Information_filter</i> scheme, or even a
particle filter such as the <i>SIR_filter</i> scheme.</p>

<h4>What does "noise coupling" in predict models mean?</h4>
<p>Predict models represent the noise with it's variance <code>q</code> and noise 'coupling' <code>G</code>.</p>
<p>These together represent the process (predict) noise. In this case the process 
model is <code>x(k+1) = f(x(k)) + G.q(k)</code> where <code>q(k)</code> in Gaussian white noise
with variance <code>q</code>.</p>
<dl>
<dt>This leads to a Kalman filter covariance update for the linear case:</dt>
<dd><code>X(k+1) = F.X(k).F' + G.q.G'</code></dd>
<dt>This is equivalent to</dt>
<dd><code>X(k+1) = F.X(k).F' + Q</code> where <code>Q = G.q.G'</code></dd>
</dl>
<p>The are a couple of reasons for expressing the process noise in this way.
a) For factorised filters (such as the UD_scheme) it is in the perfect form
b) The same noise is often additive to more then one element of the state. In this 
case the size of q is less then x and G provides a physically easily 
interpreted of how the elements of q effect x.</p>

<h4>How do I find my way around the documentation?</h4>
<p>The introductory and conceptual information can be found in the
<a href="Bayesian%20Filtering%20Classes.html">Bayesian Filtering Classes</a> document.
The <a href="Bayes++.html">documentation generated by Doxygen</a>
provides a complete reference of all the class and member names and
their relationships. For information on a particular Scheme and how it
works it is best to look at its individual header file. The filter
class headers <b>BayesFlt.hpp</b> also provide information on commonly
used and inherited class members such as state variables.</p>

<p>High on my priority list is make this component information visible in the Doxygen documentation.</p>

<h4>The simpleExample.cpp outputs <code>my_filter.x &lt;&lt; my_filter.X &lt;&lt; endl<br>
</code>&nbsp;&nbsp;&nbsp; What does this mean?</h4>
<p><i>my_filter</i> is a variable of type <i>Unscented_scheme</i>. This is one of the many filter <a href="#What_is_a_Scheme">Schemes</a>.
In the class hierarchy <i>Unscented_scheme</i> inherits from the filter class <i>State_filter</i>.
This class defines the member variables <code>x</code> and <code>X</code>. The former is a vector and stores the estimated state.
The latter is a Matrix and stores the estimated state covariance. To understand these variables mean it is worth spending some time with a Kalman filtering text book or web site.</p>

<h4>Do I need to program in C++ to use Bayes++?</h4>
<p>Yes! Bayes++ was developed to provide the maximum functionality in
C++. A good C++ text book will help you understand how Bayes++ works.
There is no need to learn C programming first. Learning C is not a
good introduction to modern C++ programming techniques used in
Bayes++. I would recommend Deitel and Deitel, "C++: How to
Program", Second Edition, Prentice Hall, ISBN 0-13-528910-6. It
is an excellent beginners book; and includes many useful tips and a
thorough understanding of the language.</p>

<h4>Is Bayes++ stable?</h4>
<p>Although many things have been added to Bayes++ over the last two
years they have only added to the variety of implementations.
Bayes++'s interface has now reached a very mature stage with little
or no change required to add new Schemes. Be aware however that the
Matrix support implementation (anything in namespace
Bayesian_filter_matrix) may change to accommodate matrix library
changes.</p>
<p>The implementations of filtering Schemes included in the web
release, have all been tested with a standard range angle observation
problem. I also use the filtering Schemes for my own work, and so do
others at the <a href="http://www.acfr.usyd.edu.au/">Australian
Centre for Field Robotics</a> and all over the world.</p>

<h4>Where are the PDFs?</h4>
<p>Bayes rule is usually defined in term of Probability Density
Functions. However PDFs never appear in Bayes++. They are always
represented by their statistics. &nbsp;This is for good reason, there
is very little that can be done algorithmically with such a function.
However the sufficient statistics, given the assumptions of a filter,
can be easily manipulated to implement Bayes rule. This is essential
what Kalman developed for linear systems. 
</p>
<p>Each filter scheme is derived from one or more virtual base
classes that represent the statistics used. For example the
<i>Kalman_state_filter</i> and <i>Sample_filter</i> base classes.</p>

<h4>What Matrix library do you recommend?</h4>
<p>Bayes++ uses the <a href="http://www.boost.org/libs/numeric/ublas/doc/index.htm"><b>uBLAS</b></a>
library for all it matrix and vector containers and linear algebra
functions. <a href="http://www.boost.org/libs/numeric/ublas/doc/index.htm"><b>uBLAS</b></a>
is part of the larger <a href="http://www.boost.org/"><b>Boost</b></a>
portable C++ source libraries. uBLAS is an excellent basic linear
algebra library. The interface and syntax are easy to use. It
provides a wide variety of matrix and vector containers and a
complete set of Basic Linear Algebra operations. The implementation
and structure can incorporate many future enhancements and efficiency
improvements. The more I use uBLAS the more I like it! See also my
note on <a href="http://www.crystalclearsoftware.com/cgi-bin/boost_wiki/wiki.pl?Effective_UBLAS">Effective
uBLAS</a> on the Boost Wiki.</p>
<p>Credit for uBLAS goes to Joerg Walter and Mathias Koch. Many thanks!</p>
<p>Older releases of Bayes++ support both uBLAS and <a href="http://www.osl.iu.edu/research/mtl/">MTL
the Matrix Template Library</a>. Future releases of MTL may also be
of interest to Bayes++. However at present nothing is being publicly
released so I will await the outcome.</p>
<p>In principle it is possible to use a different matrix library when
Bayes++ is built. This just requires a new version of <b>matSubSup.hpp</b>
to be found before the one supplied in Bayes++ itself. However
Bayes++ makes extensive use of uBLAS syntax, so a change is a
significant task.</p>

<h4>Does Bayes++ need the LAPACK library? OR<br>I get link errors,
'sgetrs_', 'dgetrf_', etc are missing, why?</h4>
<p>Normally Bayes++ does not need LAPACK at all. These functions are
part of the LAPACK linear algebra library. 
</p>
<p>The LAPACK functions for QR factorization are only used by the
<i>Information_root_scheme</i>. So unless you use this scheme or the
<b>uLAPACK.hpp</b> interface functions directly you do not need
LAPACK and should not have any link problems.</p>
<p>If you do wish to use the <i>Information_root_scheme</i>
then you will need to link with LAPACK. There are several ways
to do this depending on you requirements and system. If you use a
Linux distribution it probably has LAPACK available as a package.
Then all you need to do is install the package and add <b>-llapack
-lg2c</b> to your link options.</p>
<p>If you use Windows then you will have to do a lot more yourself.
The whole LAPACK library is available from <b>www.netlib.org</b> in
source form. Look for CLAPACK which is the C translation of the
Fortran original. It is not necessary to compile the whole library,
it is possible to use individual functions which can be downloaded as
separate files.</p>

<h4>Is is possible to fix the size of a Bayes++ classes at compile time?</h4>
<p>No. The Scheme and Model size's are run time variables specified when
the class is constructed. This makes sense, as we want to be able to
create models and filters of varying sizes. Of course this is essential
for applications like SLAM.</p>
<p>If size was a template parameter (and therefore fixed at compile time)
then otherwise identical classes of different size would have a
different type. This would make them hard to store in containers and
would defeat some of the polymorphic properties which allow algorithms
be easily chosen based on combined Scheme and Model types.</p>

<h5>Would this be more efficient?</h5>
<p>Yes and No. For each different size the compiler must produce code for
that instance. For small sizes (1,2,3 and maybe 4) this makes sense.
For more general sizes the number of possible different code versions
soon becomes unmanagable. This results in incredible code bloat and
indirectly slower code.</p>

<h4>Why is it not possible to choose Matrix types and their Storage for the Bayes++ classes?</h4>
<p>There should be a method by which the classes allow you to
choose the matrix types and their storage method. For example storing fixed size matrices with
uBLAS bounded_array could make things more efficient.</p>
<p>At the moment the only way 
to do this is to provide an alternative to the <b>matSupSub.hpp</b> header. This is 
ugly and only allows you to choose a matrix implementation for the whole 
application. For example I can compile and test Bayes++ with sparse matricies.</p>
<p>This should be be done by templateising all the classes! I decided not to do this 
for three good reasons:</p>
<ol>
  <li>Compiling is slow and debugging is cryptic. I have left the 
templatising boundry at the matrix library interface. Maybe using some future 
C++ compilation system this will change!</li>
  <li>Scheme and Model class type would depend on these implementation 
details. Otherwise identical classes would have a
different type as mention above it sizes where fixed with template parameters.
  </li>
  <li>Many algorithms require additional matrices numeric working. The <i>best</i> implementation 
of these is not directly related to the matrix types in the interface. The 
these implementation details would have to be exposed so their type can be specified.
  </li>
</ol>

</body></html>
